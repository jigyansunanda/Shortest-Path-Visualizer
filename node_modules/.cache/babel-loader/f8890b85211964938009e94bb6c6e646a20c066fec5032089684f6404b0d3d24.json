{"ast":null,"code":"import Editor from\"@monaco-editor/react\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var options={readOnly:true,minimap:{enabled:false},automaticLayout:true,scrollBeyondLastLine:false,fontSize:\"13px\",lineNumbers:\"off\",glyphMargin:false,folding:false,lineDecorationsWidth:5,renderIndentGuides:false};var BellmanFordcode=\"function BellmanFord(Graph[V, E], source, destination) {\\n    1. intialize distance[V] = {INF, INF, INF, INF, INF,........}\\n    2. distance[source] = 0\\n    3. for (count 0 to |V|-1) {\\n        \\tfor (Every edge u to v) {\\n            \\tif (distance[v] > distance[u] + weight(u, v)) {\\n                \\tdistance[v] = distance[u] + weight(u, v)\\n            \\t}\\n        \\t}\\n    \\t}\\n    /* For detection of negative weighted edge cycles,\\n    we run one more loop to check whether finalized \\n\\tdistances are further reducing or not. If yes,\\n\\tthen report negative weighted edge cycle. */\\n    4. for (every edge u to v) {\\n            if (distance[v] > distance[u] + weight(u, v)) {\\n                Report (negative weighted edge cycle exists)\\n            }\\n        }\\n    5. return distance[detination]\\n}\";var BellmanFordInfo=function BellmanFordInfo(){return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"p\",{children:[/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"Bellman-Ford\"}),\"\\xA0shortest path algorithm is a\\xA0\",/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://en.wikipedia.org/wiki/Dynamic_programming\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"dynamic programming\"}),\"\\xA0based algorithm that computes from source node to all reachable nodes. This algorithm was proposed by Alfonso Shimbel and was named after it's publishers Richard Bellman and Lester Ford Jr. .Even though this algorithm is\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"relatively slower than Dijkstra's algorithm\"}),\", it has one major advantage that, it\",/*#__PURE__*/_jsx(\"strong\",{children:\"can detect negative weighted edge cycles\"}),\".\"]}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Idea behind the algorithm:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[\"The key idea of the algorithm is\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"If there are |V| vertices in a graph (that does not contain negative weighted edge cycles), then any existing shortest path, between any source and destination vertex can not have length more than |V|-1\"}),\".\"]}),/*#__PURE__*/_jsx(\"li\",{children:\"We first find out the shortest path containing 1 edge, then shortest path containing 2 edges, then 3 edges and so on..\"})]})]})}),/*#__PURE__*/_jsx(Editor,{width:\"100%\",height:\"35vh\",theme:\"vs-dark\",defaultLanguage:\"javascript\",defaultValue:BellmanFordcode,value:BellmanFordcode,options:options}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsxs(\"strong\",{children:[\"Time Complexity: \",/*#__PURE__*/_jsx(\"code\",{children:\"O(|V||E|)\"})]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Where, \",/*#__PURE__*/_jsx(\"code\",{children:\"|V|\"}),\"\\xA0 = number of vertices and\",/*#__PURE__*/_jsx(\"code\",{children:\"|E|\"}),\"\\xA0 = number of edges\"]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Advantages:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"weighted & unweighted\"}),\" graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both \",/*#__PURE__*/_jsx(\"strong\",{children:\"cyclic & acyclic\"}),\"\\xA0graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"directed & undirected\"}),\" graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for \",/*#__PURE__*/_jsx(\"strong\",{children:\"negative weight edges\"})]}),/*#__PURE__*/_jsx(\"li\",{children:\"Detects negative weight edge cycles, if any\"})]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Disadvantages:\"}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsx(\"li\",{children:\"slower than Dijkstra's algorithm\"})})]})]})]});};export default BellmanFordInfo;","map":{"version":3,"names":["Editor","options","readOnly","minimap","enabled","automaticLayout","scrollBeyondLastLine","fontSize","lineNumbers","glyphMargin","folding","lineDecorationsWidth","renderIndentGuides","BellmanFordcode","BellmanFordInfo"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/components/algorithms-info/info/BellmanFordInfo.js"],"sourcesContent":["import Editor from \"@monaco-editor/react\";\n\nconst options = {\n    readOnly: true,\n    minimap: { enabled: false },\n    automaticLayout: true,\n    scrollBeyondLastLine: false,\n    fontSize: \"13px\",\n    lineNumbers: \"off\",\n    glyphMargin: false,\n    folding: false,\n    lineDecorationsWidth: 5,\n    renderIndentGuides: false,\n};\n\nconst BellmanFordcode = `function BellmanFord(Graph[V, E], source, destination) {\n    1. intialize distance[V] = {INF, INF, INF, INF, INF,........}\n    2. distance[source] = 0\n    3. for (count 0 to |V|-1) {\n        \tfor (Every edge u to v) {\n            \tif (distance[v] > distance[u] + weight(u, v)) {\n                \tdistance[v] = distance[u] + weight(u, v)\n            \t}\n        \t}\n    \t}\n    /* For detection of negative weighted edge cycles,\n    we run one more loop to check whether finalized \n\tdistances are further reducing or not. If yes,\n\tthen report negative weighted edge cycle. */\n    4. for (every edge u to v) {\n            if (distance[v] > distance[u] + weight(u, v)) {\n                Report (negative weighted edge cycle exists)\n            }\n        }\n    5. return distance[detination]\n}`;\n\nconst BellmanFordInfo = () => {\n    return (\n        <div>\n            <p>\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Bellman-Ford\n                </a>\n                &nbsp;shortest path algorithm is a&nbsp;\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Dynamic_programming\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    dynamic programming\n                </a>\n                &nbsp;based algorithm that computes from source node to all\n                reachable nodes. This algorithm was proposed by Alfonso Shimbel\n                and was named after it's publishers Richard Bellman and Lester\n                Ford Jr. .Even though this algorithm is&nbsp;\n                <strong>relatively slower than Dijkstra's algorithm</strong>, it\n                has one major advantage that, it\n                <strong>can detect negative weighted edge cycles</strong>.\n            </p>\n            <ul>\n                <li>\n                    <strong>Idea behind the algorithm:</strong>\n                    <ul>\n                        <li>\n                            The key idea of the algorithm is&nbsp;\n                            <strong>\n                                If there are |V| vertices in a graph (that does\n                                not contain negative weighted edge cycles), then\n                                any existing shortest path, between any source\n                                and destination vertex can not have length more\n                                than |V|-1\n                            </strong>\n                            .\n                        </li>\n                        <li>\n                            We first find out the shortest path containing 1\n                            edge, then shortest path containing 2 edges, then 3\n                            edges and so on..\n                        </li>\n                    </ul>\n                </li>\n            </ul>\n            <Editor\n                width=\"100%\"\n                height=\"35vh\"\n                theme=\"vs-dark\"\n                defaultLanguage=\"javascript\"\n                defaultValue={BellmanFordcode}\n                value={BellmanFordcode}\n                options={options}\n            />\n            <ul>\n                <li>\n                    <strong>\n                        Time Complexity: <code>O(|V||E|)</code>\n                    </strong>\n                    <p>\n                        Where, <code>|V|</code>&nbsp; = number of vertices and\n                        <code>|E|</code>&nbsp; = number of edges\n                    </p>\n                </li>\n                <li>\n                    <strong>Advantages:</strong>\n                    <ul>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>weighted & unweighted</strong> graph\n                        </li>\n                        <li>\n                            Works for both <strong>cyclic & acyclic</strong>\n                            &nbsp;graph\n                        </li>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>directed & undirected</strong> graph\n                        </li>\n                        <li>\n                            Works for <strong>negative weight edges</strong>\n                        </li>\n                        <li>Detects negative weight edge cycles, if any</li>\n                    </ul>\n                </li>\n                <li>\n                    <strong>Disadvantages:</strong>\n                    <ul>\n                        <li>slower than Dijkstra's algorithm</li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n    );\n};\n\nexport default BellmanFordInfo;\n"],"mappings":"AAAA,MAAOA,OAAM,KAAM,sBAAsB,CAAC,wFAE1C,GAAMC,QAAO,CAAG,CACZC,QAAQ,CAAE,IAAI,CACdC,OAAO,CAAE,CAAEC,OAAO,CAAE,KAAM,CAAC,CAC3BC,eAAe,CAAE,IAAI,CACrBC,oBAAoB,CAAE,KAAK,CAC3BC,QAAQ,CAAE,MAAM,CAChBC,WAAW,CAAE,KAAK,CAClBC,WAAW,CAAE,KAAK,CAClBC,OAAO,CAAE,KAAK,CACdC,oBAAoB,CAAE,CAAC,CACvBC,kBAAkB,CAAE,KACxB,CAAC,CAED,GAAMC,gBAAe,izBAoBnB,CAEF,GAAMC,gBAAe,CAAG,QAAlBA,gBAAe,EAAS,CAC1B,mBACI,oCACI,kCACI,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,8DAA8D,CACnE,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,0BAGzB,qDAEJ,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,mDAAmD,CACxD,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,iCAGzB,qPAKJ,uEAA4D,sDAE5D,oEAAyD,OACzD,cACJ,iCACI,mCACI,sDAA2C,cAC3C,mCACI,0EAEI,sOAMS,OAER,cACL,8IAIK,GACJ,GACJ,EACJ,cACL,KAAC,MAAM,EACH,KAAK,CAAC,MAAM,CACZ,MAAM,CAAC,MAAM,CACb,KAAK,CAAC,SAAS,CACf,eAAe,CAAC,YAAY,CAC5B,YAAY,CAAED,eAAgB,CAC9B,KAAK,CAAEA,eAAgB,CACvB,OAAO,CAAEZ,OAAQ,EACnB,cACF,mCACI,mCACI,2DACqB,mCAAsB,GAClC,cACT,4CACW,6BAAgB,8CACvB,6BAAgB,4BAChB,GACH,cACL,mCACI,uCAA4B,cAC5B,mCACI,wDAEI,iDAAsC,YACrC,cACL,qDACmB,4CAAiC,eAE/C,cACL,wDAEI,iDAAsC,YACrC,cACL,gDACc,iDAAsC,GAC/C,cACL,mEAAoD,GACnD,GACJ,cACL,mCACI,0CAA+B,cAC/B,iCACI,wDAAyC,EACxC,GACJ,GACJ,GACH,CAEd,CAAC,CAED,cAAea,gBAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}