{"ast":null,"code":"import PriorityQueue from\"../data-structures/PriorityQueue\";var totalRows=20,totalCols=30;var dx=[0,1,0,-1];var dy=[1,0,-1,0];var isValid=function isValid(r,c){return r>=0&&c>=0&&r<totalRows&&c<totalCols;};var Dijkstra=function Dijkstra(grid,src,dst){var distance=[];var parentNodes=[];var visited=[];for(var row=0;row<totalRows;++row){var d=[];var p=[];var v=[];for(var col=0;col<totalCols;++col){d.push(Infinity);p.push(null);v.push(false);}distance.push(d);parentNodes.push(p);visited.push(v);}distance[src.row][src.col]=0;var pq=new PriorityQueue();pq.insert([src,distance[src.row][src.col]]);var visitedNodes=[];while(pq.empty()===false){var vertex=pq.extractMin();var curr=vertex[0];var _d=vertex[1];if(visited[curr.row][curr.col]===true)continue;if(curr.isDestination===true)break;visitedNodes.push([curr]);visited[curr.row][curr.col]=true;for(var dir=0;dir<4;++dir){var r=curr.row+dx[dir];var c=curr.col+dy[dir];if(isValid(r,c)){if(grid[r][c].isWall===false&&visited[r][c]===false){if(distance[r][c]>_d+grid[r][c].weight){distance[r][c]=_d+grid[r][c].weight;parentNodes[r][c]=curr;pq.insert([grid[r][c],distance[r][c]]);}}}}}var minPathLength=distance[dst.row][dst.col]-dst.weight;var shortestPathNodes=[];if(minPathLength!==Infinity){var end=parentNodes[dst.row][dst.col];while(end.isSource===false){shortestPathNodes.push(end);end=parentNodes[end.row][end.col];}}return[minPathLength,visitedNodes,shortestPathNodes];};export default Dijkstra;","map":{"version":3,"names":["PriorityQueue","totalRows","totalCols","dx","dy","isValid","r","c","Dijkstra","grid","src","dst","distance","parentNodes","visited","row","d","p","v","col","push","Infinity","pq","insert","visitedNodes","empty","vertex","extractMin","curr","isDestination","dir","isWall","weight","minPathLength","shortestPathNodes","end","isSource"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/Dijkstra.js"],"sourcesContent":["import PriorityQueue from \"../data-structures/PriorityQueue\";\n\nconst [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst Dijkstra = (grid, src, dst) => {\n    let distance = [];\n    let parentNodes = [];\n    let visited = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let d = [];\n        let p = [];\n        let v = [];\n        for (let col = 0; col < totalCols; ++col) {\n            d.push(Infinity);\n            p.push(null);\n            v.push(false);\n        }\n        distance.push(d);\n        parentNodes.push(p);\n        visited.push(v);\n    }\n    distance[src.row][src.col] = 0;\n    let pq = new PriorityQueue();\n    pq.insert([src, distance[src.row][src.col]]);\n    let visitedNodes = [];\n    while (pq.empty() === false) {\n        let vertex = pq.extractMin();\n        let curr = vertex[0];\n        let d = vertex[1];\n        if (visited[curr.row][curr.col] === true) continue;\n        if (curr.isDestination === true) break;\n        visitedNodes.push([curr]);\n        visited[curr.row][curr.col] = true;\n        for (let dir = 0; dir < 4; ++dir) {\n            let r = curr.row + dx[dir];\n            let c = curr.col + dy[dir];\n            if (isValid(r, c)) {\n                if (grid[r][c].isWall === false && visited[r][c] === false) {\n                    if (distance[r][c] > d + grid[r][c].weight) {\n                        distance[r][c] = d + grid[r][c].weight;\n                        parentNodes[r][c] = curr;\n                        pq.insert([grid[r][c], distance[r][c]]);\n                    }\n                }\n            }\n        }\n    }\n    let minPathLength = distance[dst.row][dst.col] - dst.weight;\n    let shortestPathNodes = [];\n    if (minPathLength !== Infinity) {\n        let end = parentNodes[dst.row][dst.col];\n        while (end.isSource === false) {\n            shortestPathNodes.push(end);\n            end = parentNodes[end.row][end.col];\n        }\n    }\n    return [minPathLength, visitedNodes, shortestPathNodes];\n};\n\nexport default Dijkstra;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}