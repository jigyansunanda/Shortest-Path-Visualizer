{"ast":null,"code":"var totalRows=20,totalCols=30;var dx=[0,1,0,-1];var dy=[1,0,-1,0];var isValid=function isValid(r,c){return r>=0&&c>=0&&r<totalRows&&c<totalCols;};var BellmanFord=function BellmanFord(grid,src,dst){var distance=[];var parentNodes=[];var w=[];for(var row=0;row<totalRows;++row){var d=[];var p=[];var tmp=[];for(var col=0;col<totalCols;++col){d.push(Infinity);p.push(null);tmp.push(grid[row][col].weight);}distance.push(d);parentNodes.push(p);w.push(tmp);}w[src.row][src.col]=w[dst.row][dst.col]=0;distance[src.row][src.col]=0;var relaxedNodes=[];for(var count=0;count<totalRows*totalCols;++count){var flag=false;var relaxed=[];for(var i=0;i<totalRows;++i){for(var j=0;j<totalCols;++j){var curr=grid[i][j];var x=curr.row,y=curr.col;if(curr.isWall===false&&distance[x][y]!==Infinity){for(var dir=0;dir<4;++dir){var r=x+dx[dir];var c=y+dy[dir];if(isValid(r,c)){if(grid[r][c].isWall===false){if(distance[r][c]>distance[x][y]+w[r][c]){distance[r][c]=distance[x][y]+w[r][c];flag=true;relaxed.push(grid[r][c]);parentNodes[r][c]=curr;}}}}}}}if(flag===false)break;relaxedNodes.push(relaxed);}var shortestPathNodes=[];if(distance[dst.row][dst.col]!==Infinity){var end=parentNodes[dst.row][dst.col];while(end.isSource!==true){shortestPathNodes.push(end);end=parentNodes[end.row][end.col];}}return[distance[dst.row][dst.col],relaxedNodes,shortestPathNodes];};export default BellmanFord;","map":{"version":3,"names":["totalRows","totalCols","dx","dy","isValid","r","c","BellmanFord","grid","src","dst","distance","parentNodes","w","row","d","p","tmp","col","push","Infinity","weight","relaxedNodes","count","flag","relaxed","i","j","curr","x","y","isWall","dir","shortestPathNodes","end","isSource"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/BellmanFord.js"],"sourcesContent":["const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst BellmanFord = (grid, src, dst) => {\n    let distance = [];\n    let parentNodes = [];\n    let w = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let d = [];\n        let p = [];\n        let tmp = [];\n        for (let col = 0; col < totalCols; ++col) {\n            d.push(Infinity);\n            p.push(null);\n            tmp.push(grid[row][col].weight);\n        }\n        distance.push(d);\n        parentNodes.push(p);\n        w.push(tmp);\n    }\n    w[src.row][src.col] = w[dst.row][dst.col] = 0;\n    distance[src.row][src.col] = 0;\n    let relaxedNodes = [];\n    for (let count = 0; count < totalRows * totalCols; ++count) {\n        let flag = false;\n        let relaxed = [];\n        for (let i = 0; i < totalRows; ++i) {\n            for (let j = 0; j < totalCols; ++j) {\n                let curr = grid[i][j];\n                let x = curr.row,\n                    y = curr.col;\n                if (curr.isWall === false && distance[x][y] !== Infinity) {\n                    for (let dir = 0; dir < 4; ++dir) {\n                        let r = x + dx[dir];\n                        let c = y + dy[dir];\n                        if (isValid(r, c)) {\n                            if (grid[r][c].isWall === false) {\n                                if (distance[r][c] > distance[x][y] + w[r][c]) {\n                                    distance[r][c] = distance[x][y] + w[r][c];\n                                    flag = true;\n                                    relaxed.push(grid[r][c]);\n                                    parentNodes[r][c] = curr;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (flag === false) break;\n        relaxedNodes.push(relaxed);\n    }\n    let shortestPathNodes = [];\n    if (distance[dst.row][dst.col] !== Infinity) {\n        let end = parentNodes[dst.row][dst.col];\n        while (end.isSource !== true) {\n            shortestPathNodes.push(end);\n            end = parentNodes[end.row][end.col];\n        }\n    }\n    return [distance[dst.row][dst.col], relaxedNodes, shortestPathNodes];\n};\n\nexport default BellmanFord;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}