{"ast":null,"code":"const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\nconst BellmanFord = (grid, src, dst) => {\n  let distance = [],\n    parentNodes = [],\n    w = [];\n  for (let row = 0; row < totalRows; ++row) {\n    let d = [],\n      p = [],\n      tmp = [];\n    for (let col = 0; col < totalCols; ++col) {\n      d.push(Infinity);\n      p.push(null);\n      tmp.push(grid[row][col].weight);\n    }\n    distance.push(d);\n    parentNodes.push(p);\n    w.push(tmp);\n  }\n  w[src.row][src.col] = w[dst.row][dst.col] = 0;\n  distance[src.row][src.col] = 0;\n  let relaxedNodes = [];\n  for (let count = 0; count < totalRows * totalCols; ++count) {\n    let flag = false;\n    let relaxed = [];\n    for (let i = 0; i < totalRows; ++i) {\n      for (let j = 0; j < totalCols; ++j) {\n        let curr = grid[i][j];\n        let x = curr.row,\n          y = curr.col;\n        if (curr.isWall === false && distance[x][y] !== Infinity) {\n          for (let dir = 0; dir < 4; ++dir) {\n            let r = x + dx[dir];\n            let c = y + dy[dir];\n            if (r >= 0 && c >= 0 && r < totalRows && c < totalCols) {\n              if (grid[r][c].isWall === false) {\n                if (distance[r][c] > distance[x][y] + w[r][c]) {\n                  distance[r][c] = distance[x][y] + w[r][c];\n                  flag = true;\n                  relaxed.push(grid[r][c]);\n                  parentNodes[r][c] = curr;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (flag === false) break;\n    relaxedNodes.push(relaxed);\n  }\n};\n_c = BellmanFord;\nexport default BellmanFord;\nvar _c;\n$RefreshReg$(_c, \"BellmanFord\");","map":{"version":3,"names":["totalRows","totalCols","dx","dy","BellmanFord","grid","src","dst","distance","parentNodes","w","row","d","p","tmp","col","push","Infinity","weight","relaxedNodes","count","flag","relaxed","i","j","curr","x","y","isWall","dir","r","c"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/BellmanFord.js"],"sourcesContent":["const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst BellmanFord = (grid, src, dst) => {\n    let distance = [],\n        parentNodes = [],\n        w = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let d = [],\n            p = [],\n            tmp = [];\n        for (let col = 0; col < totalCols; ++col) {\n            d.push(Infinity);\n            p.push(null);\n            tmp.push(grid[row][col].weight);\n        }\n        distance.push(d);\n        parentNodes.push(p);\n        w.push(tmp);\n    }\n    w[src.row][src.col] = w[dst.row][dst.col] = 0;\n    distance[src.row][src.col] = 0;\n\n    let relaxedNodes = [];\n    for (let count = 0; count < totalRows * totalCols; ++count) {\n        let flag = false;\n        let relaxed = [];\n        for (let i = 0; i < totalRows; ++i) {\n            for (let j = 0; j < totalCols; ++j) {\n                let curr = grid[i][j];\n                let x = curr.row,\n                    y = curr.col;\n                if (curr.isWall === false && distance[x][y] !== Infinity) {\n                    for (let dir = 0; dir < 4; ++dir) {\n                        let r = x + dx[dir];\n                        let c = y + dy[dir];\n                        if (\n                            r >= 0 &&\n                            c >= 0 &&\n                            r < totalRows &&\n                            c < totalCols\n                        ) {\n                            if (grid[r][c].isWall === false) {\n                                if (distance[r][c] > distance[x][y] + w[r][c]) {\n                                    distance[r][c] = distance[x][y] + w[r][c];\n                                    flag = true;\n                                    relaxed.push(grid[r][c]);\n                                    parentNodes[r][c] = curr;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (flag === false) break;\n        relaxedNodes.push(relaxed);\n    }\n};\n\nexport default BellmanFord;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}