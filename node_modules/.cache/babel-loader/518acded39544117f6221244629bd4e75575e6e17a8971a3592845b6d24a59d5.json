{"ast":null,"code":"import _slicedToArray from\"/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";var totalRows=20,totalCols=30;var dx=[0,1,0,-1];var dy=[1,0,-1,0];var isValid=function isValid(r,c){return r>=0&&c>=0&&r<totalRows&&c<totalCols;};var getIndex=function getIndex(r,c){return r*totalCols+c;};var getRowCol=function getRowCol(index){var r=Math.floor(index/totalCols);var c=index-r*totalCols;return[r,c];};var FloydWarshall=function FloydWarshall(grid,src,dst){var w=[];for(var row=0;row<totalRows;++row){var tmp=[];for(var col=0;col<totalCols;++col){tmp.push(grid[row][col].weight);}w.push(tmp);}w[src.row][src.col]=w[dst.row][dst.col]=0;/*\n    Number of rows = number of columns = 600 (total possible vertices).\n\n    childNode[][]: to keep track of child Node of Nodes included in the shortest path \n    from source to destination. \n\n    childNode[a][b]: first intermediate Node in shortest path from Node a to Node b.\n\n    Initialize:\n    childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n    childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n\n    Update:\n    childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n    */var childNode=[];for(var i=0;i<totalRows*totalCols;++i){childNode.push(new Array(totalRows*totalCols));}/*\n    distance[][]: number of rows = number of cols = 600 (total possible vertices)\n\n    Initialize:\n    distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n    distance[i][j] = weight of edge connecting from Node i to Node j\n    */var distance=[];for(var _i=0;_i<totalRows*totalCols;++_i){distance.push(new Array(totalRows*totalCols));}/* fill distance[][] and childNode[][] */for(var _row=0;_row<totalRows;++_row){for(var _col=0;_col<totalCols;++_col){var index=getIndex(_row,_col);for(var k=0;k<totalRows*totalCols;++k){if(k===index){distance[index][k]=0;}else{distance[index][k]=Infinity;childNode[index][k]=-1;}}if(grid[_row][_col].isWall===false){for(var dir=0;dir<4;++dir){var x=_row+dx[dir];var y=_col+dy[dir];if(isValid(x,y)){if(grid[x][y].isWall===false){var nextIndex=getIndex(x,y);distance[index][nextIndex]=grid[x][y].weight;childNode[index][nextIndex]=nextIndex;}}}}}}var visitedNodes=[];for(var _k=0;_k<totalRows*totalCols;++_k){var _getRowCol=getRowCol(_k),_getRowCol2=_slicedToArray(_getRowCol,2),_x=_getRowCol2[0],_y=_getRowCol2[1];var middle=grid[_x][_y];if(middle.isWall===true)continue;visitedNodes.push([middle]);for(var _i2=0;_i2<totalRows*totalCols;++_i2){if(distance[_i2][_k]===Infinity)continue;var _getRowCol3=getRowCol(_i2),_getRowCol4=_slicedToArray(_getRowCol3,2),startx=_getRowCol4[0],starty=_getRowCol4[1];if(grid[startx][starty].isWall===true)continue;for(var j=0;j<totalRows*totalCols;++j){if(distance[_k][j]===Infinity)continue;var _getRowCol5=getRowCol(j),_getRowCol6=_slicedToArray(_getRowCol5,2),endx=_getRowCol6[0],endy=_getRowCol6[1];if(grid[endx][endy].isWall===true)continue;// dp\nif(distance[_i2][j]>distance[_i2][_k]+distance[_k][j]){distance[_i2][j]=distance[_i2][_k]+distance[_k][j];childNode[_i2][j]=childNode[_i2][_k];}}}}var a=getIndex(src.row,src.col);var b=getIndex(dst.row,dst.col);var minPathLength=distance[a][b]-dst.weight;var shortestPathNodes=[];while(a!==b){var _getRowCol7=getRowCol(a),_getRowCol8=_slicedToArray(_getRowCol7,2),_x2=_getRowCol8[0],_y2=_getRowCol8[1];if(grid[_x2][_y2].isSource===false&&grid[_x2][_y2].isDestination===false){shortestPathNodes.push(grid[_x2][_y2]);}a=childNode[a][b];}return[minPathLength,visitedNodes,shortestPathNodes];};export default FloydWarshall;","map":{"version":3,"names":["totalRows","totalCols","dx","dy","isValid","r","c","getIndex","getRowCol","index","Math","floor","FloydWarshall","grid","src","dst","w","row","tmp","col","push","weight","childNode","i","Array","distance","k","Infinity","isWall","dir","x","y","nextIndex","visitedNodes","middle","startx","starty","j","endx","endy","a","b","minPathLength","shortestPathNodes","isSource","isDestination"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/FloydWarshall.js"],"sourcesContent":["const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst getIndex = (r, c) => {\n    return r * totalCols + c;\n};\n\nconst getRowCol = (index) => {\n    let r = Math.floor(index / totalCols);\n    let c = index - r * totalCols;\n    return [r, c];\n};\n\nconst FloydWarshall = (grid, src, dst) => {\n    let w = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let tmp = [];\n        for (let col = 0; col < totalCols; ++col) {\n            tmp.push(grid[row][col].weight);\n        }\n        w.push(tmp);\n    }\n    w[src.row][src.col] = w[dst.row][dst.col] = 0;\n    /*\n    Number of rows = number of columns = 600 (total possible vertices).\n\n    childNode[][]: to keep track of child Node of Nodes included in the shortest path \n    from source to destination. \n\n    childNode[a][b]: first intermediate Node in shortest path from Node a to Node b.\n\n    Initialize:\n    childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n    childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n\n    Update:\n    childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n    */\n    let childNode = [];\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n        childNode.push(new Array(totalRows * totalCols));\n    }\n    /*\n    distance[][]: number of rows = number of cols = 600 (total possible vertices)\n\n    Initialize:\n    distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n    distance[i][j] = weight of edge connecting from Node i to Node j\n    */\n    let distance = [];\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n        distance.push(new Array(totalRows * totalCols));\n    }\n    /* fill distance[][] and childNode[][] */\n    for (let row = 0; row < totalRows; ++row) {\n        for (let col = 0; col < totalCols; ++col) {\n            let index = getIndex(row, col);\n            for (let k = 0; k < totalRows * totalCols; ++k) {\n                if (k === index) {\n                    distance[index][k] = 0;\n                } else {\n                    distance[index][k] = Infinity;\n                    childNode[index][k] = -1;\n                }\n            }\n            if (grid[row][col].isWall === false) {\n                for (let dir = 0; dir < 4; ++dir) {\n                    let x = row + dx[dir];\n                    let y = col + dy[dir];\n                    if (isValid(x, y)) {\n                        if (grid[x][y].isWall === false) {\n                            let nextIndex = getIndex(x, y);\n                            distance[index][nextIndex] = grid[x][y].weight;\n                            childNode[index][nextIndex] = nextIndex;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    let visitedNodes = [];\n    for (let k = 0; k < totalRows * totalCols; ++k) {\n        let [x, y] = getRowCol(k);\n        let middle = grid[x][y];\n        if (middle.isWall === true) continue;\n        visitedNodes.push([middle]);\n        for (let i = 0; i < totalRows * totalCols; ++i) {\n            if (distance[i][k] === Infinity) continue;\n            let [startx, starty] = getRowCol(i);\n            if (grid[startx][starty].isWall === true) continue;\n            for (let j = 0; j < totalRows * totalCols; ++j) {\n                if (distance[k][j] === Infinity) continue;\n                let [endx, endy] = getRowCol(j);\n                if (grid[endx][endy].isWall === true) continue;\n\n                // dp\n                if (distance[i][j] > distance[i][k] + distance[k][j]) {\n                    distance[i][j] = distance[i][k] + distance[k][j];\n                    childNode[i][j] = childNode[i][k];\n                }\n            }\n        }\n    }\n    let a = getIndex(src.row, src.col);\n    let b = getIndex(dst.row, dst.col);\n    let minPathLength = distance[a][b] - dst.weight;\n    let shortestPathNodes = [];\n    while (a !== b) {\n        let [x, y] = getRowCol(a);\n        if (\n            grid[x][y].isSource === false &&\n            grid[x][y].isDestination === false\n        ) {\n            shortestPathNodes.push(grid[x][y]);\n        }\n        a = childNode[a][b];\n    }\n    return [minPathLength, visitedNodes, shortestPathNodes];\n};\n\nexport default FloydWarshall;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}