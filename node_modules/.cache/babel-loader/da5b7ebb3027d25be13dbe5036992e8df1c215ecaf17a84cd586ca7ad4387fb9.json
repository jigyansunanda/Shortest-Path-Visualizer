{"ast":null,"code":"import Editor from\"@monaco-editor/react\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var options={readOnly:true,minimap:{enabled:false},automaticLayout:true,scrollBeyondLastLine:false,fontSize:\"13px\",lineNumbers:\"off\",glyphMargin:false,folding:false,lineDecorationsWidth:5,renderIndentGuides:false};var BFScode=\"function BFS(Graph[V, E], source, destination) {\\n    1. initialize distance[V] = {Infinity, Infinity, Infinity, Infinity, .......}\\n    2. distance[source] = 0\\n    3. create an empty Queue (say 'q')\\n    4. add source vertex to q\\n    5. while (q is not empty) \\n            vertex u := q.dequeue() {\\n            for (all vertices v: adjacent of u) {\\n                if (distance[v] == Infinity) {             // if vertex is not visited\\n                    distance[v] = distance[u] + 1\\n\\t\\t\\t\\t}\\n            }\\n        }\\n    6. return distance[destination]\\n}\";var BFSInfo=function BFSInfo(){return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"p\",{children:[\"Breadth First Search is a\\xA0\",/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"Single Source Shortest Path (SSSP)\"}),\"\\xA0graph traversal algorithm\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"for unweighted graphs\"}),\", in which we visit the source vertex first and mark it as visited. Then we visit all\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"adjacent, not-visited\"}),\" vertices of the source vertex, mark them visited and then we visit adjacent, not-visited vertices of these vertices and so on..\"]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Also, BFS with simple modification\\xA0\",/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://cp-algorithms.com/graph/01_bfs.html\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"(0-1 BFS)\"}),\"\\xA0can give shortest path from source to destination for\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"binary weighted graphs\"}),\".\"]}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Idea behind the algorithm:\"}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsx(\"li\",{children:/*#__PURE__*/_jsxs(\"p\",{children:[\"Since during BFS, total encounterd distance keeps increasing by 1, \",/*#__PURE__*/_jsx(\"i\",{children:\"i.e.\"}),\" we first travel source vertex (at distance 0), then travel vertices, those are at distance 1 from source, then vertices at distance 2 from source and so on. Hence, the first time we encounter a vertex, the distance covered till now, must be the shortest distance.\"]})})})]})}),/*#__PURE__*/_jsx(Editor,{width:\"100%\",height:\"30vh\",theme:\"vs-dark\",defaultLanguage:\"javascript\",defaultValue:BFScode,value:BFScode,options:options}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsxs(\"strong\",{children:[\"Time Complexity: \",/*#__PURE__*/_jsx(\"code\",{children:\"O(|V| + |E|)\"})]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Where, \",/*#__PURE__*/_jsx(\"code\",{children:\"|V|\"}),\"\\xA0 = number of vertices and\\xA0\",/*#__PURE__*/_jsx(\"code\",{children:\"|E|\"}),\"\\xA0 = number of edges\"]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsxs(\"strong\",{children:[\"Space Complexity: \",/*#__PURE__*/_jsx(\"code\",{children:\"O(|V|)\"})]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Where, \",/*#__PURE__*/_jsx(\"code\",{children:\"|V|\"}),\"\\xA0 = number of vertices\"]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Advantages:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsx(\"li\",{children:\"Gives shortest path for unweighted graph\"}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"directed & undirected\"}),\" graph\"]}),/*#__PURE__*/_jsx(\"li\",{children:\"Easy to implement\"})]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Disadvantages:\"}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsxs(\"li\",{children:[\"Does \",/*#__PURE__*/_jsx(\"strong\",{children:\"not\"}),\" work for weighted graph\"]})})]})]})]});};export default BFSInfo;","map":{"version":3,"names":["Editor","options","readOnly","minimap","enabled","automaticLayout","scrollBeyondLastLine","fontSize","lineNumbers","glyphMargin","folding","lineDecorationsWidth","renderIndentGuides","BFScode","BFSInfo"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/components/algorithms-info/info/BFSInfo.js"],"sourcesContent":["import Editor from \"@monaco-editor/react\";\n\nconst options = {\n    readOnly: true,\n    minimap: { enabled: false },\n    automaticLayout: true,\n    scrollBeyondLastLine: false,\n    fontSize: \"13px\",\n    lineNumbers: \"off\",\n    glyphMargin: false,\n    folding: false,\n    lineDecorationsWidth: 5,\n    renderIndentGuides: false,\n};\n\nconst BFScode = `function BFS(Graph[V, E], source, destination) {\n    1. initialize distance[V] = {Infinity, Infinity, Infinity, Infinity, .......}\n    2. distance[source] = 0\n    3. create an empty Queue (say 'q')\n    4. add source vertex to q\n    5. while (q is not empty) \n            vertex u := q.dequeue() {\n            for (all vertices v: adjacent of u) {\n                if (distance[v] == Infinity) {             // if vertex is not visited\n                    distance[v] = distance[u] + 1\n\t\t\t\t}\n            }\n        }\n    6. return distance[destination]\n}`;\n\nconst BFSInfo = () => {\n    return (\n        <div>\n            <p>\n                Breadth First Search is a&nbsp;\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Single Source Shortest Path (SSSP)\n                </a>\n                &nbsp;graph traversal algorithm&nbsp;\n                <strong>for unweighted graphs</strong>, in which we visit the\n                source vertex first and mark it as visited. Then we visit\n                all&nbsp;\n                <strong>adjacent, not-visited</strong> vertices of the source\n                vertex, mark them visited and then we visit adjacent,\n                not-visited vertices of these vertices and so on..\n            </p>\n            <p>\n                Also, BFS with simple modification&nbsp;\n                <a\n                    className=\"links\"\n                    href=\"https://cp-algorithms.com/graph/01_bfs.html\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    (0-1 BFS)\n                </a>\n                &nbsp;can give shortest path from source to destination\n                for&nbsp;\n                <strong>binary weighted graphs</strong>.\n            </p>\n            <ul>\n                <li>\n                    <strong>Idea behind the algorithm:</strong>\n                    <ul>\n                        <li>\n                            <p>\n                                Since during BFS, total encounterd distance\n                                keeps increasing by 1, <i>i.e.</i> we first\n                                travel source vertex (at distance 0), then\n                                travel vertices, those are at distance 1 from\n                                source, then vertices at distance 2 from source\n                                and so on. Hence, the first time we encounter a\n                                vertex, the distance covered till now, must be\n                                the shortest distance.\n                            </p>\n                        </li>\n                    </ul>\n                </li>\n            </ul>\n            <Editor\n                width=\"100%\"\n                height=\"30vh\"\n                theme=\"vs-dark\"\n                defaultLanguage=\"javascript\"\n                defaultValue={BFScode}\n                value={BFScode}\n                options={options}\n            />\n            <ul>\n                <li>\n                    <strong>\n                        Time Complexity: <code>O(|V| + |E|)</code>\n                    </strong>\n                    <p>\n                        Where, <code>|V|</code>&nbsp; = number of vertices\n                        and&nbsp;\n                        <code>|E|</code>&nbsp; = number of edges\n                    </p>\n                </li>\n                <li>\n                    <strong>\n                        Space Complexity: <code>O(|V|)</code>\n                    </strong>\n                    <p>\n                        Where, <code>|V|</code>&nbsp; = number of vertices\n                    </p>\n                </li>\n                <li>\n                    <strong>Advantages:</strong>\n                    <ul>\n                        <li>Gives shortest path for unweighted graph</li>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>directed & undirected</strong> graph\n                        </li>\n                        <li>Easy to implement</li>\n                    </ul>\n                </li>\n                <li>\n                    <strong>Disadvantages:</strong>\n                    <ul>\n                        <li>\n                            Does <strong>not</strong> work for weighted graph\n                        </li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n    );\n};\n\nexport default BFSInfo;\n"],"mappings":"AAAA,MAAOA,OAAM,KAAM,sBAAsB,CAAC,wFAE1C,GAAMC,QAAO,CAAG,CACZC,QAAQ,CAAE,IAAI,CACdC,OAAO,CAAE,CAAEC,OAAO,CAAE,KAAM,CAAC,CAC3BC,eAAe,CAAE,IAAI,CACrBC,oBAAoB,CAAE,KAAK,CAC3BC,QAAQ,CAAE,MAAM,CAChBC,WAAW,CAAE,KAAK,CAClBC,WAAW,CAAE,KAAK,CAClBC,OAAO,CAAE,KAAK,CACdC,oBAAoB,CAAE,CAAC,CACvBC,kBAAkB,CAAE,KACxB,CAAC,CAED,GAAMC,QAAO,4jBAcX,CAEF,GAAMC,QAAO,CAAG,QAAVA,QAAO,EAAS,CAClB,mBACI,oCACI,kEAEI,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,kFAAkF,CACvF,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,gDAGzB,kDAEJ,iDAAsC,0GAGtC,iDAAsC,sIAGtC,cACJ,2EAEI,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,6CAA6C,CAClD,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,uBAGzB,8EAGJ,kDAAuC,OACvC,cACJ,iCACI,mCACI,sDAA2C,cAC3C,iCACI,iCACI,wGAE2B,2BAAW,8QAOlC,EACH,EACJ,GACJ,EACJ,cACL,KAAC,MAAM,EACH,KAAK,CAAC,MAAM,CACZ,MAAM,CAAC,MAAM,CACb,KAAK,CAAC,SAAS,CACf,eAAe,CAAC,YAAY,CAC5B,YAAY,CAAED,OAAQ,CACtB,KAAK,CAAEA,OAAQ,CACf,OAAO,CAAEZ,OAAQ,EACnB,cACF,mCACI,mCACI,2DACqB,sCAAyB,GACrC,cACT,4CACW,6BAAgB,kDAEvB,6BAAgB,4BAChB,GACH,cACL,mCACI,4DACsB,gCAAmB,GAChC,cACT,4CACW,6BAAgB,+BACvB,GACH,cACL,mCACI,uCAA4B,cAC5B,mCACI,gEAAiD,cACjD,wDAEI,iDAAsC,YACrC,cACL,yCAA0B,GACzB,GACJ,cACL,mCACI,0CAA+B,cAC/B,iCACI,2CACS,+BAAoB,8BACxB,EACJ,GACJ,GACJ,GACH,CAEd,CAAC,CAED,cAAea,QAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}