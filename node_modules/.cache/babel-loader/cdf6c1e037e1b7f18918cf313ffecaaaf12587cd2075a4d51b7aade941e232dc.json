{"ast":null,"code":"const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\nconst isValid = (r, c) => {\n  return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\nconst BellmanFord = (grid, src, dst) => {\n  let distance = [];\n  let parentNodes = [];\n  let w = [];\n  for (let row = 0; row < totalRows; ++row) {\n    let d = [];\n    let p = [];\n    let tmp = [];\n    for (let col = 0; col < totalCols; ++col) {\n      d.push(Infinity);\n      p.push(null);\n      tmp.push(grid[row][col].weight);\n    }\n    distance.push(d);\n    parentNodes.push(p);\n    w.push(tmp);\n  }\n  w[src.row][src.col] = w[dst.row][dst.col] = 0;\n  distance[src.row][src.col] = 0;\n  console.log(parentNodes);\n  // let relaxedNodes = [];\n  // for (let count = 0; count < totalRows * totalCols; ++count) {\n  //     let flag = false;\n  //     let relaxed = [];\n  //     for (let i = 0; i < totalRows; ++i) {\n  //         for (let j = 0; j < totalCols; ++j) {\n  //             let curr = grid[i][j];\n  //             let x = curr.row,\n  //                 y = curr.col;\n  //             if (curr.isWall === false && distance[x][y] !== Infinity) {\n  //                 for (let dir = 0; dir < 4; ++dir) {\n  //                     let r = x + dx[dir];\n  //                     let c = y + dy[dir];\n  //                     if (isValid(r, c)) {\n  //                         if (grid[r][c].isWall === false) {\n  //                             if (distance[r][c] > distance[x][y] + w[r][c]) {\n  //                                 distance[r][c] = distance[x][y] + w[r][c];\n  //                                 flag = true;\n  //                                 relaxed.push(grid[r][c]);\n  //                                 parentNodes[r][c] = curr;\n  //                             }\n  //                         }\n  //                     }\n  //                 }\n  //             }\n  //         }\n  //     }\n  //     if (flag === false) break;\n  //     relaxedNodes.push(relaxed);\n  // }\n  // let shortestPathNodes = [];\n  // if (distance[dst.x][dst.y] !== Infinity) {\n  //     let end = parentNodes[dst.row][dst.col];\n  //     while (end.isSource !== true) {\n  //         shortestPathNodes.push(end);\n  //         end = parentNodes[end.row][end.col];\n  //     }\n  // }\n  // console.log(distance[dst.x][dst.y]);\n  // return [distance[dst.x][dst.y], relaxedNodes, shortestPathNodes];\n};\n_c = BellmanFord;\nexport default BellmanFord;\nvar _c;\n$RefreshReg$(_c, \"BellmanFord\");","map":{"version":3,"names":["totalRows","totalCols","dx","dy","isValid","r","c","BellmanFord","grid","src","dst","distance","parentNodes","w","row","d","p","tmp","col","push","Infinity","weight","console","log"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/BellmanFord.js"],"sourcesContent":["const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst BellmanFord = (grid, src, dst) => {\n    let distance = [];\n    let parentNodes = [];\n    let w = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let d = [];\n        let p = [];\n        let tmp = [];\n        for (let col = 0; col < totalCols; ++col) {\n            d.push(Infinity);\n            p.push(null);\n            tmp.push(grid[row][col].weight);\n        }\n        distance.push(d);\n        parentNodes.push(p);\n        w.push(tmp);\n    }\n    w[src.row][src.col] = w[dst.row][dst.col] = 0;\n    distance[src.row][src.col] = 0;\n    console.log(parentNodes);\n    // let relaxedNodes = [];\n    // for (let count = 0; count < totalRows * totalCols; ++count) {\n    //     let flag = false;\n    //     let relaxed = [];\n    //     for (let i = 0; i < totalRows; ++i) {\n    //         for (let j = 0; j < totalCols; ++j) {\n    //             let curr = grid[i][j];\n    //             let x = curr.row,\n    //                 y = curr.col;\n    //             if (curr.isWall === false && distance[x][y] !== Infinity) {\n    //                 for (let dir = 0; dir < 4; ++dir) {\n    //                     let r = x + dx[dir];\n    //                     let c = y + dy[dir];\n    //                     if (isValid(r, c)) {\n    //                         if (grid[r][c].isWall === false) {\n    //                             if (distance[r][c] > distance[x][y] + w[r][c]) {\n    //                                 distance[r][c] = distance[x][y] + w[r][c];\n    //                                 flag = true;\n    //                                 relaxed.push(grid[r][c]);\n    //                                 parentNodes[r][c] = curr;\n    //                             }\n    //                         }\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     }\n    //     if (flag === false) break;\n    //     relaxedNodes.push(relaxed);\n    // }\n    // let shortestPathNodes = [];\n    // if (distance[dst.x][dst.y] !== Infinity) {\n    //     let end = parentNodes[dst.row][dst.col];\n    //     while (end.isSource !== true) {\n    //         shortestPathNodes.push(end);\n    //         end = parentNodes[end.row][end.col];\n    //     }\n    // }\n    // console.log(distance[dst.x][dst.y]);\n    // return [distance[dst.x][dst.y], relaxedNodes, shortestPathNodes];\n};\n\nexport default BellmanFord;\n"],"mappings":"AAAA,MAAM,CAACA,SAAS,EAAEC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AACvC,MAAMC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACxB,MAAMC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AAExB,MAAMC,OAAO,GAAG,CAACC,CAAC,EAAEC,CAAC,KAAK;EACtB,OAAOD,CAAC,IAAI,CAAC,IAAIC,CAAC,IAAI,CAAC,IAAID,CAAC,GAAGL,SAAS,IAAIM,CAAC,GAAGL,SAAS;AAC7D,CAAC;AAED,MAAMM,WAAW,GAAG,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,KAAK;EACpC,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,CAAC,GAAG,EAAE;EACV,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGd,SAAS,EAAE,EAAEc,GAAG,EAAE;IACtC,IAAIC,CAAC,GAAG,EAAE;IACV,IAAIC,CAAC,GAAG,EAAE;IACV,IAAIC,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGjB,SAAS,EAAE,EAAEiB,GAAG,EAAE;MACtCH,CAAC,CAACI,IAAI,CAACC,QAAQ,CAAC;MAChBJ,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC;MACZF,GAAG,CAACE,IAAI,CAACX,IAAI,CAACM,GAAG,CAAC,CAACI,GAAG,CAAC,CAACG,MAAM,CAAC;IACnC;IACAV,QAAQ,CAACQ,IAAI,CAACJ,CAAC,CAAC;IAChBH,WAAW,CAACO,IAAI,CAACH,CAAC,CAAC;IACnBH,CAAC,CAACM,IAAI,CAACF,GAAG,CAAC;EACf;EACAJ,CAAC,CAACJ,GAAG,CAACK,GAAG,CAAC,CAACL,GAAG,CAACS,GAAG,CAAC,GAAGL,CAAC,CAACH,GAAG,CAACI,GAAG,CAAC,CAACJ,GAAG,CAACQ,GAAG,CAAC,GAAG,CAAC;EAC7CP,QAAQ,CAACF,GAAG,CAACK,GAAG,CAAC,CAACL,GAAG,CAACS,GAAG,CAAC,GAAG,CAAC;EAC9BI,OAAO,CAACC,GAAG,CAACX,WAAW,CAAC;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AAAC,KA5DIL,WAAW;AA8DjB,eAAeA,WAAW;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}