{"ast":null,"code":"var _jsxFileName = \"/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/components/algorithms-info/info/BFSInfo.js\";\nimport Editor from \"@monaco-editor/react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst options = {\n  readOnly: true,\n  minimap: {\n    enabled: false\n  },\n  automaticLayout: true,\n  scrollBeyondLastLine: false,\n  fontSize: \"13px\",\n  lineNumbers: \"off\",\n  glyphMargin: false,\n  folding: false,\n  lineDecorationsWidth: 5,\n  renderIndentGuides: false\n};\nconst BFScode = `function BFS(Graph[V], source, destination) {\n    1. initialize distance[V] = {Infinity, Infinity, Infinity, Infinity, .......}\n    2. distance[source] = 0\n    3. create an empty Queue (say 'q')\n    4. add source vertex to q\n    5. while (q is not empty) \n            vertex u := q.dequeue() {\n            for (all vertices v: adjacent of u) {\n                if (distance[v] == Infinity) {             // if vertex is not visited\n                    istance[v] = distance[u] + 1\n\t\t\t\t}\n            }\n        }\n    6. return distance[destination]\n}`;\nconst BFSInfo = () => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Breadth First Search is a\", \" \", /*#__PURE__*/_jsxDEV(\"a\", {\n        className: \"links\",\n        href: \"https://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"Single-Source-Shortest-Path (SSSP)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 37,\n        columnNumber: 17\n      }, this), \" \", \"graph traversal algorithm \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"for unweighted graph\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 43\n      }, this), \", in which we visit the source vertex first and mark it as visited. Then we visit all\", \" \", /*#__PURE__*/_jsxDEV(\"strong\", {\n        children: \"adjacent, not-visited\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 48,\n        columnNumber: 17\n      }, this), \" vertices of the source vertex, mark them visited and then we visit adjacent, not-visited vertices of these vertices and so on..\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Also, BFS with simple modification\", \" \", /*#__PURE__*/_jsxDEV(\"a\", {\n        className: \"links\",\n        href: \"https://cp-algorithms.com/graph/01_bfs.html\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"(0-1 BFS)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 54,\n        columnNumber: 17\n      }, this), \" \", \"can give shortest path from source to destination for\", \" \", /*#__PURE__*/_jsxDEV(\"b\", {\n        children: \"binary weighted\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 17\n      }, this), \" graph.\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"Idea behind the algorithm\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 67,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n          children: /*#__PURE__*/_jsxDEV(\"li\", {\n            children: /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Since during BFS, total encounterd distance keeps increasing by 1, \", /*#__PURE__*/_jsxDEV(\"i\", {\n                children: \"i.e.\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 72,\n                columnNumber: 56\n              }, this), \" we first travel source vertex (at distance 0), then travel vertices, those are at distance 1 from source, then vertices at distance 2 from source and so on. Hence, the first time we encounter a vertex, the distance covered till now, must be the shortest distance.\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 70,\n              columnNumber: 29\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 69,\n            columnNumber: 25\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"Idea behind the algorithm\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 82,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 66,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Editor, {\n      width: \"100%\",\n      height: \"30vh\",\n      theme: \"vs-dark\",\n      defaultLanguage: \"javascript\",\n      defaultValue: BFScode,\n      value: BFScode,\n      options: options\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 34,\n    columnNumber: 9\n  }, this);\n};\n_c = BFSInfo;\nexport default BFSInfo;\nvar _c;\n$RefreshReg$(_c, \"BFSInfo\");","map":{"version":3,"names":["Editor","options","readOnly","minimap","enabled","automaticLayout","scrollBeyondLastLine","fontSize","lineNumbers","glyphMargin","folding","lineDecorationsWidth","renderIndentGuides","BFScode","BFSInfo"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/components/algorithms-info/info/BFSInfo.js"],"sourcesContent":["import Editor from \"@monaco-editor/react\";\n\nconst options = {\n    readOnly: true,\n    minimap: { enabled: false },\n    automaticLayout: true,\n    scrollBeyondLastLine: false,\n    fontSize: \"13px\",\n    lineNumbers: \"off\",\n    glyphMargin: false,\n    folding: false,\n    lineDecorationsWidth: 5,\n    renderIndentGuides: false,\n};\n\nconst BFScode = `function BFS(Graph[V], source, destination) {\n    1. initialize distance[V] = {Infinity, Infinity, Infinity, Infinity, .......}\n    2. distance[source] = 0\n    3. create an empty Queue (say 'q')\n    4. add source vertex to q\n    5. while (q is not empty) \n            vertex u := q.dequeue() {\n            for (all vertices v: adjacent of u) {\n                if (distance[v] == Infinity) {             // if vertex is not visited\n                    istance[v] = distance[u] + 1\n\t\t\t\t}\n            }\n        }\n    6. return distance[destination]\n}`;\n\nconst BFSInfo = () => {\n    return (\n        <div>\n            <p>\n                Breadth First Search is a{\" \"}\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Single-Source-Shortest-Path (SSSP)\n                </a>{\" \"}\n                graph traversal algorithm <strong>for unweighted graph</strong>,\n                in which we visit the source vertex first and mark it as\n                visited. Then we visit all{\" \"}\n                <strong>adjacent, not-visited</strong> vertices of the source\n                vertex, mark them visited and then we visit adjacent,\n                not-visited vertices of these vertices and so on..\n            </p>\n            <p>\n                Also, BFS with simple modification{\" \"}\n                <a\n                    className=\"links\"\n                    href=\"https://cp-algorithms.com/graph/01_bfs.html\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    (0-1 BFS)\n                </a>{\" \"}\n                can give shortest path from source to destination for{\" \"}\n                <b>binary weighted</b> graph.\n            </p>\n            <ul>\n                <li>\n                    <strong>Idea behind the algorithm</strong>\n                    <ul>\n                        <li>\n                            <p>\n                                Since during BFS, total encounterd distance\n                                keeps increasing by 1, <i>i.e.</i> we first\n                                travel source vertex (at distance 0), then\n                                travel vertices, those are at distance 1 from\n                                source, then vertices at distance 2 from source\n                                and so on. Hence, the first time we encounter a\n                                vertex, the distance covered till now, must be\n                                the shortest distance.\n                            </p>\n                        </li>\n                    </ul>\n                    <strong>Idea behind the algorithm</strong>\n                </li>\n            </ul>\n            <Editor\n                width=\"100%\"\n                height=\"30vh\"\n                theme=\"vs-dark\"\n                defaultLanguage=\"javascript\"\n                defaultValue={BFScode}\n                value={BFScode}\n                options={options}\n            />\n        </div>\n    );\n};\n\nexport default BFSInfo;\n"],"mappings":";AAAA,OAAOA,MAAM,MAAM,sBAAsB;AAAC;AAE1C,MAAMC,OAAO,GAAG;EACZC,QAAQ,EAAE,IAAI;EACdC,OAAO,EAAE;IAAEC,OAAO,EAAE;EAAM,CAAC;EAC3BC,eAAe,EAAE,IAAI;EACrBC,oBAAoB,EAAE,KAAK;EAC3BC,QAAQ,EAAE,MAAM;EAChBC,WAAW,EAAE,KAAK;EAClBC,WAAW,EAAE,KAAK;EAClBC,OAAO,EAAE,KAAK;EACdC,oBAAoB,EAAE,CAAC;EACvBC,kBAAkB,EAAE;AACxB,CAAC;AAED,MAAMC,OAAO,GAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEF,MAAMC,OAAO,GAAG,MAAM;EAClB,oBACI;IAAA,wBACI;MAAA,wCAC8B,GAAG,eAC7B;QACI,SAAS,EAAC,OAAO;QACjB,IAAI,EAAC,kFAAkF;QACvF,MAAM,EAAC,QAAQ;QACf,GAAG,EAAC,qBAAqB;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAGzB,EAAC,GAAG,6CACkB;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAAqC,2FAEpC,GAAG,eAC9B;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAAsC;IAAA;MAAA;MAAA;MAAA;IAAA,QAGtC,eACJ;MAAA,iDACuC,GAAG,eACtC;QACI,SAAS,EAAC,OAAO;QACjB,IAAI,EAAC,6CAA6C;QAClD,MAAM,EAAC,QAAQ;QACf,GAAG,EAAC,qBAAqB;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAGzB,EAAC,GAAG,2DAC8C,GAAG,eACzD;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAAsB;IAAA;MAAA;MAAA;MAAA;IAAA,QACtB,eACJ;MAAA,uBACI;QAAA,wBACI;UAAA;QAAA;UAAA;UAAA;UAAA;QAAA,QAA0C,eAC1C;UAAA,uBACI;YAAA,uBACI;cAAA,+FAE2B;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA,QAAW;YAAA;cAAA;cAAA;cAAA;YAAA;UAOlC;YAAA;YAAA;YAAA;UAAA;QACH;UAAA;UAAA;UAAA;QAAA,QACJ,eACL;UAAA;QAAA;UAAA;UAAA;UAAA;QAAA,QAA0C;MAAA;QAAA;QAAA;QAAA;MAAA;IACzC;MAAA;MAAA;MAAA;IAAA,QACJ,eACL,QAAC,MAAM;MACH,KAAK,EAAC,MAAM;MACZ,MAAM,EAAC,MAAM;MACb,KAAK,EAAC,SAAS;MACf,eAAe,EAAC,YAAY;MAC5B,YAAY,EAAED,OAAQ;MACtB,KAAK,EAAEA,OAAQ;MACf,OAAO,EAAEZ;IAAQ;MAAA;MAAA;MAAA;IAAA,QACnB;EAAA;IAAA;IAAA;IAAA;EAAA,QACA;AAEd,CAAC;AAAC,KAhEIa,OAAO;AAkEb,eAAeA,OAAO;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}