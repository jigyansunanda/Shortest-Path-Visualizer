{"ast":null,"code":"import Editor from\"@monaco-editor/react\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var options={readOnly:true,minimap:{enabled:false},automaticLayout:true,scrollBeyondLastLine:false,fontSize:\"13px\",lineNumbers:\"off\",glyphMargin:false,folding:false,lineDecorationsWidth:5,renderIndentGuides:false};var Dijkstracode=\"function Dijkstra(Graph[V, E], source, destination) {\\n    1. create a Priority Queue (Min Heap), say 'pq'\\n    2. intialize distance[V] = {Infinity, Infinity, Infinity, Infinity, ........}\\n    3. distance[source] = 0\\n    4. insert all vertices with distance[vertex] to pq                      // O(|V|) time\\n    5. while (pq is not empty) {                                            // loop runs |V| times\\n            vertex u := extract vertex with minimum distance from pq        // O(log |V|) time\\n            if (u == destination) {\\n                return distance[destination]\\n            }\\n            for (all vertices v: adjacent of u) {\\n                if (distance[v] > distance[u] + weight(u, v)) {\\n                    distance[v] = distance[u] + weight(u, v)\\n                    insert vertex v with distance[v] to pq                  // Total time: O((|E| + |V|) log |V|)\\n                }\\n            }\\n        }\\n}\";var DijkstraInfo=function DijkstraInfo(){return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"p\",{children:[\"Dijkstra's \",/*#__PURE__*/_jsx(\"strong\",{children:\"Shortest Path First (SPF)\"}),\" algorithm is a \",/*#__PURE__*/_jsx(\"strong\",{children:\"greedy\"}),\"\\xA0\",/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"Single Source Shortest Path (SSSP)\"}),\"\\xA0 algorithm, conceived by\\xA0\",/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://en.wikipedia.org/wiki/Edsger_W._Dijkstra\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"Edsger. W Dijkstra\"}),\"\\xA0in 1956.\"]}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Idea behind the algorithm:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsx(\"li\",{children:\"We maintain a container of distance for all vertices initialized with values Infinite.\"}),/*#__PURE__*/_jsx(\"li\",{children:\"Distance of source vertex is 0.\"}),/*#__PURE__*/_jsx(\"li\",{children:\"At each iteration, we pick a vertex and finalize it distance. Initially none of the vertices have their distance finalized.\"}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"How do we pick the vertex ?\"}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsx(\"li\",{children:\"We pick the vertex for which distance has not been finalized and has minimum distance. (greedy choice)\"})})]}),/*#__PURE__*/_jsx(\"li\",{children:\"Then we go to all adjacent vertices of it, and check whether do we get a shorter path to those vertices, through current vertex, If yes, then we update it's distance.\"})]})]})}),/*#__PURE__*/_jsx(Editor,{width:\"100%\",height:\"30vh\",theme:\"vs-dark\",defaultLanguage:\"javascript\",defaultValue:Dijkstracode,value:Dijkstracode,options:options}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsxs(\"strong\",{children:[\"Time Complexity: \",/*#__PURE__*/_jsx(\"code\",{children:\"O((|V| + |E|) log |V|)\"})]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Where, \",/*#__PURE__*/_jsx(\"code\",{children:\"|V|\"}),\"\\xA0 = number of vertices and\\xA0\",/*#__PURE__*/_jsx(\"code\",{children:\"|E|\"}),\"\\xA0 = number of edges\"]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Advantages:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"weighted & unweighted\"}),\" graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both \",/*#__PURE__*/_jsx(\"strong\",{children:\"cyclic & acyclic\"}),\"\\xA0graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"directed & undirected\"}),\" graph\"]})]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Disadvantages:\"}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsxs(\"li\",{children:[\"Does \",/*#__PURE__*/_jsx(\"strong\",{children:\"not\"}),\" work for graphs with\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"negative weighted edges\"})]})})]})]})]});};export default DijkstraInfo;","map":{"version":3,"names":["Editor","options","readOnly","minimap","enabled","automaticLayout","scrollBeyondLastLine","fontSize","lineNumbers","glyphMargin","folding","lineDecorationsWidth","renderIndentGuides","Dijkstracode","DijkstraInfo"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/components/algorithms-info/info/DijkstraInfo.js"],"sourcesContent":["import Editor from \"@monaco-editor/react\";\n\nconst options = {\n    readOnly: true,\n    minimap: { enabled: false },\n    automaticLayout: true,\n    scrollBeyondLastLine: false,\n    fontSize: \"13px\",\n    lineNumbers: \"off\",\n    glyphMargin: false,\n    folding: false,\n    lineDecorationsWidth: 5,\n    renderIndentGuides: false,\n};\n\nconst Dijkstracode = `function Dijkstra(Graph[V, E], source, destination) {\n    1. create a Priority Queue (Min Heap), say 'pq'\n    2. intialize distance[V] = {Infinity, Infinity, Infinity, Infinity, ........}\n    3. distance[source] = 0\n    4. insert all vertices with distance[vertex] to pq                      // O(|V|) time\n    5. while (pq is not empty) {                                            // loop runs |V| times\n            vertex u := extract vertex with minimum distance from pq        // O(log |V|) time\n            if (u == destination) {\n                return distance[destination]\n            }\n            for (all vertices v: adjacent of u) {\n                if (distance[v] > distance[u] + weight(u, v)) {\n                    distance[v] = distance[u] + weight(u, v)\n                    insert vertex v with distance[v] to pq                  // Total time: O((|E| + |V|) log |V|)\n                }\n            }\n        }\n}`;\n\nconst DijkstraInfo = () => {\n    return (\n        <div>\n            <p>\n                Dijkstra's <strong>Shortest Path First (SPF)</strong> algorithm\n                is a <strong>greedy</strong>&nbsp;\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Shortest_path_problem#Single-source_shortest_paths\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Single Source Shortest Path (SSSP)\n                </a>\n                &nbsp; algorithm, conceived by&nbsp;\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Edsger_W._Dijkstra\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Edsger. W Dijkstra\n                </a>\n                &nbsp;in 1956.\n            </p>\n            <ul>\n                <li>\n                    <strong>Idea behind the algorithm:</strong>\n                    <ul>\n                        <li>\n                            We maintain a container of distance for all vertices\n                            initialized with values Infinite.\n                        </li>\n                        <li>Distance of source vertex is 0.</li>\n                        <li>\n                            At each iteration, we pick a vertex and finalize it\n                            distance. Initially none of the vertices have their\n                            distance finalized.\n                        </li>\n                        <li>\n                            <strong>How do we pick the vertex ?</strong>\n                            <ul>\n                                <li>\n                                    We pick the vertex for which distance has\n                                    not been finalized and has minimum distance.\n                                    (greedy choice)\n                                </li>\n                            </ul>\n                        </li>\n                        <li>\n                            Then we go to all adjacent vertices of it, and check\n                            whether do we get a shorter path to those vertices,\n                            through current vertex, If yes, then we update it's\n                            distance.\n                        </li>\n                    </ul>\n                </li>\n            </ul>\n            <Editor\n                width=\"100%\"\n                height=\"30vh\"\n                theme=\"vs-dark\"\n                defaultLanguage=\"javascript\"\n                defaultValue={Dijkstracode}\n                value={Dijkstracode}\n                options={options}\n            />\n            <ul>\n                <li>\n                    <strong>\n                        Time Complexity: <code>O((|V| + |E|) log |V|)</code>\n                    </strong>\n                    <p>\n                        Where, <code>|V|</code>&nbsp; = number of vertices\n                        and&nbsp;\n                        <code>|E|</code>&nbsp; = number of edges\n                    </p>\n                </li>\n                <li>\n                    <strong>Advantages:</strong>\n                    <ul>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>weighted & unweighted</strong> graph\n                        </li>\n                        <li>\n                            Works for both <strong>cyclic & acyclic</strong>\n                            &nbsp;graph\n                        </li>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>directed & undirected</strong> graph\n                        </li>\n                    </ul>\n                </li>\n                <li>\n                    <strong>Disadvantages:</strong>\n                    <ul>\n                        <li>\n                            Does <strong>not</strong> work for graphs with&nbsp;\n                            <strong>negative weighted edges</strong>\n                        </li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n    );\n};\n\nexport default DijkstraInfo;\n"],"mappings":"AAAA,MAAOA,OAAM,KAAM,sBAAsB,CAAC,wFAE1C,GAAMC,QAAO,CAAG,CACZC,QAAQ,CAAE,IAAI,CACdC,OAAO,CAAE,CAAEC,OAAO,CAAE,KAAM,CAAC,CAC3BC,eAAe,CAAE,IAAI,CACrBC,oBAAoB,CAAE,KAAK,CAC3BC,QAAQ,CAAE,MAAM,CAChBC,WAAW,CAAE,KAAK,CAClBC,WAAW,CAAE,KAAK,CAClBC,OAAO,CAAE,KAAK,CACdC,oBAAoB,CAAE,CAAC,CACvBC,kBAAkB,CAAE,KACxB,CAAC,CAED,GAAMC,aAAY,o7BAiBhB,CAEF,GAAMC,aAAY,CAAG,QAAfA,aAAY,EAAS,CACvB,mBACI,oCACI,gDACe,qDAA0C,iCAChD,kCAAuB,qBAC5B,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,kFAAkF,CACvF,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,gDAGzB,iDAEJ,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,kDAAkD,CACvD,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,gCAGzB,kBAEJ,cACJ,iCACI,mCACI,sDAA2C,cAC3C,mCACI,8GAGK,cACL,uDAAwC,cACxC,mJAIK,cACL,mCACI,uDAA4C,cAC5C,iCACI,8HAIK,EACJ,GACJ,cACL,8LAKK,GACJ,GACJ,EACJ,cACL,KAAC,MAAM,EACH,KAAK,CAAC,MAAM,CACZ,MAAM,CAAC,MAAM,CACb,KAAK,CAAC,SAAS,CACf,eAAe,CAAC,YAAY,CAC5B,YAAY,CAAED,YAAa,CAC3B,KAAK,CAAEA,YAAa,CACpB,OAAO,CAAEZ,OAAQ,EACnB,cACF,mCACI,mCACI,2DACqB,gDAAmC,GAC/C,cACT,4CACW,6BAAgB,kDAEvB,6BAAgB,4BAChB,GACH,cACL,mCACI,uCAA4B,cAC5B,mCACI,wDAEI,iDAAsC,YACrC,cACL,qDACmB,4CAAiC,eAE/C,cACL,wDAEI,iDAAsC,YACrC,GACJ,GACJ,cACL,mCACI,0CAA+B,cAC/B,iCACI,2CACS,+BAAoB,0CACzB,mDAAwC,GACvC,EACJ,GACJ,GACJ,GACH,CAEd,CAAC,CAED,cAAea,aAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}