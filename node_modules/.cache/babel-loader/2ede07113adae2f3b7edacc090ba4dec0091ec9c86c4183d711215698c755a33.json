{"ast":null,"code":"/*\ncustom implemented Priority Queue :-\n\nwith Binary Min-Heap, i.e. The key with minimum required\nvalue (distance, in this algorithmic implementation) will have \nhighest priority hence will be present in the top of the Priority Queue,\nto be processed or removed first. \n\nWe will use it in Dijkstra's Algorithm.\n*/\n\nconst maxSize = 80000;\nclass PriorityQueue {\n  constructor() {\n    this.heap = new Array(maxSize);\n    this.size = 0;\n  }\n  // left-child Node of Node at index i\n  left(i) {\n    return i * 2 + 1;\n  }\n  // right-child Node of Node at index i\n  right(i) {\n    return i * 2 + 2;\n  }\n  // parent Node of Node at index i\n  parent(i) {\n    return Math.floor((i - 1) / 2);\n  }\n  // check whether PriorityQueue is empty or not\n  empty() {\n    return this.size === 0;\n  }\n  // check whether PriorityQueue is full or not\n  full() {\n    return this.size === maxSize;\n  }\n  // insert an item into PriorityQueue\n  insert(key) {\n    if (this.size === maxSize) return;\n    this.size += 1;\n    this.heap[this.size - 1] = key;\n    let i = this.size - 1;\n    while (i !== 0 && this.heap[i][1] < this.heap[this.parent(i)][1]) {\n      let tmp = this.heap[i];\n      this.heap[i] = this.heap[this.parent(i)];\n      this.heap[this.parent(i)] = tmp;\n      i = this.parent(i);\n    }\n  }\n  // heapify the priority queue\n  heapify(i) {\n    if (i >= this.size) return;\n    let smaller = i;\n    let l = this.left(i);\n    let r = this.right(i);\n    if (l < this.size && this.heap[l][1] < this.heap[smaller][1]) {\n      smaller = l;\n    }\n    if (r < this.size && this.heap[r][1] < this.heap[smaller][1]) {\n      smaller = r;\n    }\n    if (smaller !== i) {\n      let tmp = this.heap[smaller];\n      this.heap[smaller] = this.heap[i];\n      this.heap[i] = tmp;\n      this.heapify(smaller);\n    }\n  }\n  // extract minimum from priority queue\n  extractMin() {\n    if (this.size === 0) return Infinity;\n    var tmp = this.heap[0];\n    this.heap[0] = this.heap[this.size - 1];\n    this.size -= 1;\n    this.heapify(0);\n    return tmp;\n  }\n  // decrease key value\n  decreaseKey(i, value) {\n    if (i >= this.size) return;\n    this.heap[i][1] = value;\n    while (i !== 0 && this.heap[i][1] < this.heap[this.parent(i)][1]) {\n      var tmp = this.heap[this.parent(i)];\n      this.heap[this.parent(i)] = this.heap[i];\n      this.heap[i] = tmp;\n      i = this.parent(i);\n    }\n  }\n  // delete key from priority queue\n  deleteKey(thisX, thisY) {\n    for (let i = 0; i < this.size; i++) {\n      if (this.heap[i][0].x === thisX && this.heap[i][0].y === thisY) {\n        this.decreaseKey(i, -Infinity);\n        this.extractMin();\n        break;\n      }\n    }\n  }\n}\nexport default PriorityQueue;","map":{"version":3,"names":["maxSize","PriorityQueue","constructor","heap","Array","size","left","i","right","parent","Math","floor","empty","full","insert","key","tmp","heapify","smaller","l","r","extractMin","Infinity","decreaseKey","value","deleteKey","thisX","thisY","x","y"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/data-structures/PriorityQueue.js"],"sourcesContent":["/*\ncustom implemented Priority Queue :-\n\nwith Binary Min-Heap, i.e. The key with minimum required\nvalue (distance, in this algorithmic implementation) will have \nhighest priority hence will be present in the top of the Priority Queue,\nto be processed or removed first. \n\nWe will use it in Dijkstra's Algorithm.\n*/\n\nconst maxSize = 80000;\n\nclass PriorityQueue {\n    constructor() {\n        this.heap = new Array(maxSize);\n        this.size = 0;\n    }\n    // left-child Node of Node at index i\n    left(i) {\n        return i * 2 + 1;\n    }\n    // right-child Node of Node at index i\n    right(i) {\n        return i * 2 + 2;\n    }\n    // parent Node of Node at index i\n    parent(i) {\n        return Math.floor((i - 1) / 2);\n    }\n    // check whether PriorityQueue is empty or not\n    empty() {\n        return this.size === 0;\n    }\n    // check whether PriorityQueue is full or not\n    full() {\n        return this.size === maxSize;\n    }\n    // insert an item into PriorityQueue\n    insert(key) {\n        if (this.size === maxSize) return;\n        this.size += 1;\n        this.heap[this.size - 1] = key;\n        let i = this.size - 1;\n        while (i !== 0 && this.heap[i][1] < this.heap[this.parent(i)][1]) {\n            let tmp = this.heap[i];\n            this.heap[i] = this.heap[this.parent(i)];\n            this.heap[this.parent(i)] = tmp;\n            i = this.parent(i);\n        }\n    }\n    // heapify the priority queue\n    heapify(i) {\n        if (i >= this.size) return;\n        let smaller = i;\n        let l = this.left(i);\n        let r = this.right(i);\n        if (l < this.size && this.heap[l][1] < this.heap[smaller][1]) {\n            smaller = l;\n        }\n        if (r < this.size && this.heap[r][1] < this.heap[smaller][1]) {\n            smaller = r;\n        }\n        if (smaller !== i) {\n            let tmp = this.heap[smaller];\n            this.heap[smaller] = this.heap[i];\n            this.heap[i] = tmp;\n            this.heapify(smaller);\n        }\n    }\n    // extract minimum from priority queue\n    extractMin() {\n        if (this.size === 0) return Infinity;\n        var tmp = this.heap[0];\n        this.heap[0] = this.heap[this.size - 1];\n        this.size -= 1;\n        this.heapify(0);\n        return tmp;\n    }\n    // decrease key value\n    decreaseKey(i, value) {\n        if (i >= this.size) return;\n        this.heap[i][1] = value;\n        while (i !== 0 && this.heap[i][1] < this.heap[this.parent(i)][1]) {\n            var tmp = this.heap[this.parent(i)];\n            this.heap[this.parent(i)] = this.heap[i];\n            this.heap[i] = tmp;\n            i = this.parent(i);\n        }\n    }\n    // delete key from priority queue\n    deleteKey(thisX, thisY) {\n        for (let i = 0; i < this.size; i++) {\n            if (this.heap[i][0].x === thisX && this.heap[i][0].y === thisY) {\n                this.decreaseKey(i, -Infinity);\n                this.extractMin();\n                break;\n            }\n        }\n    }\n}\n\nexport default PriorityQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}