{"ast":null,"code":"import Queue from \"../data-structures/Queue.js\";\nconst [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\nconst isValid = (r, c) => {\n  return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\nconst BFS = (grid, src, dst) => {\n  let distance = [];\n  let parentNodes = [];\n  for (let row = 0; row < totalRows; ++row) {\n    let d = [];\n    let p = [];\n    for (let col = 0; col < totalCols; ++col) {\n      d.push(Infinity);\n      p.push(null);\n    }\n    distance.push(d);\n    parentNodes.push(p);\n  }\n  distance[src.row][src.col] = 0;\n  let q = new Queue();\n  q.enqueue(src);\n  let pathFound = false;\n  let visitedNodes = [];\n  while (q.empty() === false) {\n    let currSize = q.size();\n    let newVisitedNodes = [];\n    for (let z = 0; z < currSize; ++z) {\n      let curr = q.dequeue();\n      if (curr.isDestination === true) {\n        pathFound = true;\n        break;\n      }\n      for (let dir = 0; dir < 4; ++dir) {\n        let r = curr.row + dx[dir];\n        let c = curr.col + dy[dir];\n        if (isValid(r, c)) {\n          let adj = grid[r][c];\n          if (adj.isWall === false) {\n            if (distance[r][c] === Infinity) {\n              distance[r][c] = distance[curr.row][curr.col] + 1;\n              newVisitedNodes.push(adj);\n              parentNodes[r][c] = curr;\n              q.enqueue(adj);\n            }\n          }\n        }\n      }\n    }\n    if (pathFound === true) break;\n    visitedNodes.push(newVisitedNodes);\n  }\n  let shortestPathNodes = [];\n  if (pathFound === true) {\n    let end = parentNodes[dst.row][dst.col];\n    while (end.isSource !== true) {\n      shortestPathNodes.push(end);\n      end = parentNodes[end.row][end.col];\n    }\n  }\n  return [distance[dst.row][dst.col], visitedNodes, shortestPathNodes];\n};\n_c = BFS;\nexport default BFS;\nvar _c;\n$RefreshReg$(_c, \"BFS\");","map":{"version":3,"names":["Queue","totalRows","totalCols","dx","dy","isValid","r","c","BFS","grid","src","dst","distance","parentNodes","row","d","p","col","push","Infinity","q","enqueue","pathFound","visitedNodes","empty","currSize","size","newVisitedNodes","z","curr","dequeue","isDestination","dir","adj","isWall","shortestPathNodes","end","isSource"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/BFS.js"],"sourcesContent":["import Queue from \"../data-structures/Queue.js\";\n\nconst [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst BFS = (grid, src, dst) => {\n    let distance = [];\n    let parentNodes = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let d = [];\n        let p = [];\n        for (let col = 0; col < totalCols; ++col) {\n            d.push(Infinity);\n            p.push(null);\n        }\n        distance.push(d);\n        parentNodes.push(p);\n    }\n    distance[src.row][src.col] = 0;\n    let q = new Queue();\n    q.enqueue(src);\n    let pathFound = false;\n    let visitedNodes = [];\n    while (q.empty() === false) {\n        let currSize = q.size();\n        let newVisitedNodes = [];\n        for (let z = 0; z < currSize; ++z) {\n            let curr = q.dequeue();\n            if (curr.isDestination === true) {\n                pathFound = true;\n                break;\n            }\n            for (let dir = 0; dir < 4; ++dir) {\n                let r = curr.row + dx[dir];\n                let c = curr.col + dy[dir];\n                if (isValid(r, c)) {\n                    let adj = grid[r][c];\n                    if (adj.isWall === false) {\n                        if (distance[r][c] === Infinity) {\n                            distance[r][c] = distance[curr.row][curr.col] + 1;\n                            newVisitedNodes.push(adj);\n                            parentNodes[r][c] = curr;\n                            q.enqueue(adj);\n                        }\n                    }\n                }\n            }\n        }\n        if (pathFound === true) break;\n        visitedNodes.push(newVisitedNodes);\n    }\n    let shortestPathNodes = [];\n    if (pathFound === true) {\n        let end = parentNodes[dst.row][dst.col];\n        while (end.isSource !== true) {\n            shortestPathNodes.push(end);\n            end = parentNodes[end.row][end.col];\n        }\n    }\n    return [distance[dst.row][dst.col], visitedNodes, shortestPathNodes];\n};\n\nexport default BFS;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,6BAA6B;AAE/C,MAAM,CAACC,SAAS,EAAEC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AACvC,MAAMC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACxB,MAAMC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AAExB,MAAMC,OAAO,GAAG,CAACC,CAAC,EAAEC,CAAC,KAAK;EACtB,OAAOD,CAAC,IAAI,CAAC,IAAIC,CAAC,IAAI,CAAC,IAAID,CAAC,GAAGL,SAAS,IAAIM,CAAC,GAAGL,SAAS;AAC7D,CAAC;AAED,MAAMM,GAAG,GAAG,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,KAAK;EAC5B,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,WAAW,GAAG,EAAE;EACpB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGb,SAAS,EAAE,EAAEa,GAAG,EAAE;IACtC,IAAIC,CAAC,GAAG,EAAE;IACV,IAAIC,CAAC,GAAG,EAAE;IACV,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGf,SAAS,EAAE,EAAEe,GAAG,EAAE;MACtCF,CAAC,CAACG,IAAI,CAACC,QAAQ,CAAC;MAChBH,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC;IAChB;IACAN,QAAQ,CAACM,IAAI,CAACH,CAAC,CAAC;IAChBF,WAAW,CAACK,IAAI,CAACF,CAAC,CAAC;EACvB;EACAJ,QAAQ,CAACF,GAAG,CAACI,GAAG,CAAC,CAACJ,GAAG,CAACO,GAAG,CAAC,GAAG,CAAC;EAC9B,IAAIG,CAAC,GAAG,IAAIpB,KAAK,EAAE;EACnBoB,CAAC,CAACC,OAAO,CAACX,GAAG,CAAC;EACd,IAAIY,SAAS,GAAG,KAAK;EACrB,IAAIC,YAAY,GAAG,EAAE;EACrB,OAAOH,CAAC,CAACI,KAAK,EAAE,KAAK,KAAK,EAAE;IACxB,IAAIC,QAAQ,GAAGL,CAAC,CAACM,IAAI,EAAE;IACvB,IAAIC,eAAe,GAAG,EAAE;IACxB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,EAAE,EAAEG,CAAC,EAAE;MAC/B,IAAIC,IAAI,GAAGT,CAAC,CAACU,OAAO,EAAE;MACtB,IAAID,IAAI,CAACE,aAAa,KAAK,IAAI,EAAE;QAC7BT,SAAS,GAAG,IAAI;QAChB;MACJ;MACA,KAAK,IAAIU,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAE,EAAEA,GAAG,EAAE;QAC9B,IAAI1B,CAAC,GAAGuB,IAAI,CAACf,GAAG,GAAGX,EAAE,CAAC6B,GAAG,CAAC;QAC1B,IAAIzB,CAAC,GAAGsB,IAAI,CAACZ,GAAG,GAAGb,EAAE,CAAC4B,GAAG,CAAC;QAC1B,IAAI3B,OAAO,CAACC,CAAC,EAAEC,CAAC,CAAC,EAAE;UACf,IAAI0B,GAAG,GAAGxB,IAAI,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC;UACpB,IAAI0B,GAAG,CAACC,MAAM,KAAK,KAAK,EAAE;YACtB,IAAItB,QAAQ,CAACN,CAAC,CAAC,CAACC,CAAC,CAAC,KAAKY,QAAQ,EAAE;cAC7BP,QAAQ,CAACN,CAAC,CAAC,CAACC,CAAC,CAAC,GAAGK,QAAQ,CAACiB,IAAI,CAACf,GAAG,CAAC,CAACe,IAAI,CAACZ,GAAG,CAAC,GAAG,CAAC;cACjDU,eAAe,CAACT,IAAI,CAACe,GAAG,CAAC;cACzBpB,WAAW,CAACP,CAAC,CAAC,CAACC,CAAC,CAAC,GAAGsB,IAAI;cACxBT,CAAC,CAACC,OAAO,CAACY,GAAG,CAAC;YAClB;UACJ;QACJ;MACJ;IACJ;IACA,IAAIX,SAAS,KAAK,IAAI,EAAE;IACxBC,YAAY,CAACL,IAAI,CAACS,eAAe,CAAC;EACtC;EACA,IAAIQ,iBAAiB,GAAG,EAAE;EAC1B,IAAIb,SAAS,KAAK,IAAI,EAAE;IACpB,IAAIc,GAAG,GAAGvB,WAAW,CAACF,GAAG,CAACG,GAAG,CAAC,CAACH,GAAG,CAACM,GAAG,CAAC;IACvC,OAAOmB,GAAG,CAACC,QAAQ,KAAK,IAAI,EAAE;MAC1BF,iBAAiB,CAACjB,IAAI,CAACkB,GAAG,CAAC;MAC3BA,GAAG,GAAGvB,WAAW,CAACuB,GAAG,CAACtB,GAAG,CAAC,CAACsB,GAAG,CAACnB,GAAG,CAAC;IACvC;EACJ;EACA,OAAO,CAACL,QAAQ,CAACD,GAAG,CAACG,GAAG,CAAC,CAACH,GAAG,CAACM,GAAG,CAAC,EAAEM,YAAY,EAAEY,iBAAiB,CAAC;AACxE,CAAC;AAAC,KAvDI3B,GAAG;AAyDT,eAAeA,GAAG;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}