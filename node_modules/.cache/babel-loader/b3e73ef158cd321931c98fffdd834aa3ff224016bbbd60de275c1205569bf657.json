{"ast":null,"code":"const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\nconst isValid = (r, c) => {\n  return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\nconst getIndex = (r, c) => {\n  return r * totalCols + c;\n};\nconst getRowCol = index => {\n  let r = Math.floor(index / totalCols);\n  let c = index - r * totalCols;\n  return [r, c];\n};\nconst FloydWarshall = (grid, src, dst) => {\n  let w = [];\n  for (let row = 0; row < totalRows; ++row) {\n    let tmp = [];\n    for (let col = 0; col < totalCols; ++col) {\n      tmp.push(grid[row][col].weight);\n    }\n    w.push(tmp);\n  }\n  w[src.row][src.col] = w[dst.row][dst.col] = 0;\n  /*\n  Number of rows = number of columns = 600 (total possible vertices).\n   childNode[][]: to keep track of child Node of Nodes included in the shortest path \n  from source to destination. \n   childNode[a][b]: first intermediate Node in shortest path from Node a to Node b.\n   Initialize:\n  childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n  childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n   Update:\n  childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n  */\n  let childNode = [];\n  for (let i = 0; i < totalRows * totalCols; ++i) {\n    childNode.push(new Array(totalRows * totalCols));\n  }\n  /*\n  distance[][]: number of rows = number of cols = 600 (total possible vertices)\n   Initialize:\n  distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n  distance[i][j] = weight of edge connecting from Node i to Node j\n  */\n  let distance = [];\n  for (let i = 0; i < totalRows * totalCols; ++i) {\n    distance.push(new Array(totalRows * totalCols));\n  }\n  /* fill distance[][] and childNode[][] */\n  for (let row = 0; row < totalRows; ++row) {\n    for (let col = 0; col < totalCols; ++col) {\n      let index = getIndex(row, col);\n      for (let k = 0; k < totalRows * totalCols; ++k) {\n        if (k === index) {\n          distance[index][k] = 0;\n        } else {\n          distance[index][k] = Infinity;\n          childNode[index][k] = -1;\n        }\n      }\n      if (grid[row][col].isWall === false) {\n        for (let dir = 0; dir < 4; ++dir) {\n          let x = row + dx[dir];\n          let y = col + dy[dir];\n          if (isValid(x, y)) {\n            if (grid[x][y].isWall === false) {\n              let nextIndex = getIndex(x, y);\n              distance[index][nextIndex] = grid[x][y].weight;\n              childNode[index][nextIndex] = nextIndex;\n            }\n          }\n        }\n      }\n    }\n  }\n  for (let k = 0; k < totalRows * totalCols; ++k) {\n    let [x, y] = getRowCol(k);\n    let middle = grid[x][y];\n    if (middle.isWall === true) continue;\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n      if (distance[i][k] === Infinity) continue;\n      let [startx, starty] = getRowCol(i);\n      if (grid[startx][starty].isWall === true) continue;\n      for (let j = 0; j < totalRows * totalCols; ++j) {\n        if (distance[k][j] === Infinity) continue;\n        let [endx, endy] = getRowCol(j);\n        if (grid[endx][endy].isWall === true) continue;\n\n        // dp\n        if (distance[i][j] > distance[i][k] + distance[k][j]) {\n          distance[i][j] = distance[i][k] + distance[k][j];\n          childNode[i][j] = childNode[i][k];\n        }\n      }\n    }\n  }\n  let a = getIndex(src.row, src.col);\n  let b = getIndex(dst.row, dst.col);\n  return [src.weight, dst.weight, distance[a][b] - dst.weight];\n};\n_c = FloydWarshall;\nexport default FloydWarshall;\nvar _c;\n$RefreshReg$(_c, \"FloydWarshall\");","map":{"version":3,"names":["totalRows","totalCols","dx","dy","isValid","r","c","getIndex","getRowCol","index","Math","floor","FloydWarshall","grid","src","dst","w","row","tmp","col","push","weight","childNode","i","Array","distance","k","Infinity","isWall","dir","x","y","nextIndex","middle","startx","starty","j","endx","endy","a","b"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/FloydWarshall.js"],"sourcesContent":["const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst getIndex = (r, c) => {\n    return r * totalCols + c;\n};\n\nconst getRowCol = (index) => {\n    let r = Math.floor(index / totalCols);\n    let c = index - r * totalCols;\n    return [r, c];\n};\n\nconst FloydWarshall = (grid, src, dst) => {\n    let w = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let tmp = [];\n        for (let col = 0; col < totalCols; ++col) {\n            tmp.push(grid[row][col].weight);\n        }\n        w.push(tmp);\n    }\n    w[src.row][src.col] = w[dst.row][dst.col] = 0;\n    /*\n    Number of rows = number of columns = 600 (total possible vertices).\n\n    childNode[][]: to keep track of child Node of Nodes included in the shortest path \n    from source to destination. \n\n    childNode[a][b]: first intermediate Node in shortest path from Node a to Node b.\n\n    Initialize:\n    childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n    childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n\n    Update:\n    childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n    */\n    let childNode = [];\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n        childNode.push(new Array(totalRows * totalCols));\n    }\n    /*\n    distance[][]: number of rows = number of cols = 600 (total possible vertices)\n\n    Initialize:\n    distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n    distance[i][j] = weight of edge connecting from Node i to Node j\n    */\n    let distance = [];\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n        distance.push(new Array(totalRows * totalCols));\n    }\n    /* fill distance[][] and childNode[][] */\n    for (let row = 0; row < totalRows; ++row) {\n        for (let col = 0; col < totalCols; ++col) {\n            let index = getIndex(row, col);\n            for (let k = 0; k < totalRows * totalCols; ++k) {\n                if (k === index) {\n                    distance[index][k] = 0;\n                } else {\n                    distance[index][k] = Infinity;\n                    childNode[index][k] = -1;\n                }\n            }\n            if (grid[row][col].isWall === false) {\n                for (let dir = 0; dir < 4; ++dir) {\n                    let x = row + dx[dir];\n                    let y = col + dy[dir];\n                    if (isValid(x, y)) {\n                        if (grid[x][y].isWall === false) {\n                            let nextIndex = getIndex(x, y);\n                            distance[index][nextIndex] = grid[x][y].weight;\n                            childNode[index][nextIndex] = nextIndex;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (let k = 0; k < totalRows * totalCols; ++k) {\n        let [x, y] = getRowCol(k);\n        let middle = grid[x][y];\n        if (middle.isWall === true) continue;\n        for (let i = 0; i < totalRows * totalCols; ++i) {\n            if (distance[i][k] === Infinity) continue;\n            let [startx, starty] = getRowCol(i);\n            if (grid[startx][starty].isWall === true) continue;\n            for (let j = 0; j < totalRows * totalCols; ++j) {\n                if (distance[k][j] === Infinity) continue;\n                let [endx, endy] = getRowCol(j);\n                if (grid[endx][endy].isWall === true) continue;\n\n                // dp\n                if (distance[i][j] > distance[i][k] + distance[k][j]) {\n                    distance[i][j] = distance[i][k] + distance[k][j];\n                    childNode[i][j] = childNode[i][k];\n                }\n            }\n        }\n    }\n    let a = getIndex(src.row, src.col);\n    let b = getIndex(dst.row, dst.col);\n    return [src.weight, dst.weight, distance[a][b] - dst.weight];\n};\n\nexport default FloydWarshall;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}