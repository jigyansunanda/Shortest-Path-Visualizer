{"ast":null,"code":"import PriorityQueue from \"../data-structures/PriorityQueue\";\nconst [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\nconst isValid = (r, c) => {\n  return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\nconst Dijkstra = (grid, src, dst) => {\n  let distance = [];\n  let parentNodes = [];\n  let visited = [];\n  for (let row = 0; row < totalRows; ++row) {\n    let d = [];\n    let p = [];\n    let v = [];\n    for (let col = 0; col < totalCols; ++col) {\n      d.push(Infinity);\n      p.push(null);\n      v.push(false);\n    }\n    distance.push(d);\n    parentNodes.push(p);\n    visited.push(v);\n  }\n  distance[src.row][src.col] = 0;\n  let pq = new PriorityQueue();\n  pq.insert([src, distance[src.row][src.col]]);\n  let visitedNodes = [];\n  while (pq.empty() === false) {\n    let vertex = pq.extractMin();\n    let curr = vertex[0];\n    let d = vertex[1];\n    if (visited[curr.row][curr.col] === true) continue;\n    if (curr.isDestination === true) break;\n    visitedNodes.push([curr]);\n    visited[curr.row][curr.col] = true;\n    for (let dir = 0; dir < 4; ++dir) {\n      let r = curr.row + dx[dir];\n      let c = curr.col + dy[dir];\n      if (isValid(r, c)) {\n        if (grid[r][c].isWall === false && visited[r][c] === false) {\n          if (distance[r][c] > d + grid[r][c].weight) {\n            distance[r][c] = d + grid[r][c].weight;\n            parentNodes[r][c] = curr;\n            pq.insert([grid[r][c], distance[r][c]]);\n          }\n        }\n      }\n    }\n  }\n  let minPathLength = distance[dst.row][dst.col] - dst.weight;\n  let shortestPathNodes = [];\n  if (minPathLength !== Infinity) {\n    let end = parentNodes[dst.row][dst.col];\n    while (end.isSource === false) {\n      shortestPathNodes.push(end);\n      end = parentNodes[end.row][end.col];\n    }\n  }\n  return [minPathLength, visitedNodes, shortestPathNodes];\n};\n_c = Dijkstra;\nexport default Dijkstra;\nvar _c;\n$RefreshReg$(_c, \"Dijkstra\");","map":{"version":3,"names":["PriorityQueue","totalRows","totalCols","dx","dy","isValid","r","c","Dijkstra","grid","src","dst","distance","parentNodes","visited","row","d","p","v","col","push","Infinity","pq","insert","visitedNodes","empty","vertex","extractMin","curr","isDestination","dir","isWall","weight","minPathLength","shortestPathNodes","end","isSource"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/Dijkstra.js"],"sourcesContent":["import PriorityQueue from \"../data-structures/PriorityQueue\";\n\nconst [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst Dijkstra = (grid, src, dst) => {\n    let distance = [];\n    let parentNodes = [];\n    let visited = [];\n    for (let row = 0; row < totalRows; ++row) {\n        let d = [];\n        let p = [];\n        let v = [];\n        for (let col = 0; col < totalCols; ++col) {\n            d.push(Infinity);\n            p.push(null);\n            v.push(false);\n        }\n        distance.push(d);\n        parentNodes.push(p);\n        visited.push(v);\n    }\n    distance[src.row][src.col] = 0;\n    let pq = new PriorityQueue();\n    pq.insert([src, distance[src.row][src.col]]);\n    let visitedNodes = [];\n    while (pq.empty() === false) {\n        let vertex = pq.extractMin();\n        let curr = vertex[0];\n        let d = vertex[1];\n        if (visited[curr.row][curr.col] === true) continue;\n        if (curr.isDestination === true) break;\n        visitedNodes.push([curr]);\n        visited[curr.row][curr.col] = true;\n        for (let dir = 0; dir < 4; ++dir) {\n            let r = curr.row + dx[dir];\n            let c = curr.col + dy[dir];\n            if (isValid(r, c)) {\n                if (grid[r][c].isWall === false && visited[r][c] === false) {\n                    if (distance[r][c] > d + grid[r][c].weight) {\n                        distance[r][c] = d + grid[r][c].weight;\n                        parentNodes[r][c] = curr;\n                        pq.insert([grid[r][c], distance[r][c]]);\n                    }\n                }\n            }\n        }\n    }\n    let minPathLength = distance[dst.row][dst.col] - dst.weight;\n    let shortestPathNodes = [];\n    if (minPathLength !== Infinity) {\n        let end = parentNodes[dst.row][dst.col];\n        while (end.isSource === false) {\n            shortestPathNodes.push(end);\n            end = parentNodes[end.row][end.col];\n        }\n    }\n    return [minPathLength, visitedNodes, shortestPathNodes];\n};\n\nexport default Dijkstra;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}