{"ast":null,"code":"const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\nconst isValid = (r, c) => {\n  return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\nconst getIndex = (r, c) => {\n  return r * totalCols + c;\n};\nconst FloydWarshall = (grid, src, dst) => {\n  /*\n  Number of rows = number of columns = 600 (total possible vertices).\n   childNode[][]: to keep track of child Node of Nodes included in the shortest path \n  from source to destination. \n   childNode[a][b]: first intermediate Node in shortest path from Node a to Node b.\n   Initialize:\n  childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n  childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n   Update:\n  childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n  */\n  let childNode = [];\n  for (let i = 0; i < totalRows * totalCols; ++i) {\n    childNode.push(new Array(totalRows * totalCols));\n  }\n  /*\n  distance[][]: number of rows = number of cols = 600 (total possible vertices)\n   Initialize:\n  distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n  distance[i][j] = weight of edge connecting from Node i to Node j\n  */\n  let distance = [];\n  for (let i = 0; i < totalRows * totalCols; ++i) {\n    distance.push(new Array(totalRows * totalCols));\n  }\n  /* fill distance[][] and childNode[][] */\n  for (let row = 0; row < totalRows; ++row) {\n    for (let col = 0; col < totalCols; ++col) {\n      let index = getIndex(row, col);\n    }\n  }\n};\n_c = FloydWarshall;\nexport default FloydWarshall;\nvar _c;\n$RefreshReg$(_c, \"FloydWarshall\");","map":{"version":3,"names":["totalRows","totalCols","dx","dy","isValid","r","c","getIndex","FloydWarshall","grid","src","dst","childNode","i","push","Array","distance","row","col","index"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/algorithms/FloydWarshall.js"],"sourcesContent":["const [totalRows, totalCols] = [20, 30];\nconst dx = [0, 1, 0, -1];\nconst dy = [1, 0, -1, 0];\n\nconst isValid = (r, c) => {\n    return r >= 0 && c >= 0 && r < totalRows && c < totalCols;\n};\n\nconst getIndex = (r, c) => {\n    return r * totalCols + c;\n};\n\nconst FloydWarshall = (grid, src, dst) => {\n    /*\n    Number of rows = number of columns = 600 (total possible vertices).\n\n    childNode[][]: to keep track of child Node of Nodes included in the shortest path \n    from source to destination. \n\n    childNode[a][b]: first intermediate Node in shortest path from Node a to Node b.\n\n    Initialize:\n    childNode[a][b] = -1 (if no edge connecting from Node a to Node b)\n    childNode[a][b] = b (if b is adjacent reachable Node from Node a)\n\n    Update:\n    childNode[a][b] = childNode[a][c] (if distance[a][b] > distance[a][c] + distance[c][b])\n    */\n    let childNode = [];\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n        childNode.push(new Array(totalRows * totalCols));\n    }\n    /*\n    distance[][]: number of rows = number of cols = 600 (total possible vertices)\n\n    Initialize:\n    distance[i][j] = Infinity (if no edge connecting from Node i to Node j)\n    distance[i][j] = weight of edge connecting from Node i to Node j\n    */\n    let distance = [];\n    for (let i = 0; i < totalRows * totalCols; ++i) {\n        distance.push(new Array(totalRows * totalCols));\n    }\n    /* fill distance[][] and childNode[][] */\n    for (let row = 0; row < totalRows; ++row) {\n        for (let col = 0; col < totalCols; ++col) {\n            let index = getIndex(row, col);\n        }\n    }\n};\n\nexport default FloydWarshall;\n"],"mappings":"AAAA,MAAM,CAACA,SAAS,EAAEC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AACvC,MAAMC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACxB,MAAMC,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AAExB,MAAMC,OAAO,GAAG,CAACC,CAAC,EAAEC,CAAC,KAAK;EACtB,OAAOD,CAAC,IAAI,CAAC,IAAIC,CAAC,IAAI,CAAC,IAAID,CAAC,GAAGL,SAAS,IAAIM,CAAC,GAAGL,SAAS;AAC7D,CAAC;AAED,MAAMM,QAAQ,GAAG,CAACF,CAAC,EAAEC,CAAC,KAAK;EACvB,OAAOD,CAAC,GAAGJ,SAAS,GAAGK,CAAC;AAC5B,CAAC;AAED,MAAME,aAAa,GAAG,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,KAAK;EACtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAKI,IAAIC,SAAS,GAAG,EAAE;EAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,SAAS,GAAGC,SAAS,EAAE,EAAEY,CAAC,EAAE;IAC5CD,SAAS,CAACE,IAAI,CAAC,IAAIC,KAAK,CAACf,SAAS,GAAGC,SAAS,CAAC,CAAC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;EAEI,IAAIe,QAAQ,GAAG,EAAE;EACjB,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,SAAS,GAAGC,SAAS,EAAE,EAAEY,CAAC,EAAE;IAC5CG,QAAQ,CAACF,IAAI,CAAC,IAAIC,KAAK,CAACf,SAAS,GAAGC,SAAS,CAAC,CAAC;EACnD;EACA;EACA,KAAK,IAAIgB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGjB,SAAS,EAAE,EAAEiB,GAAG,EAAE;IACtC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGjB,SAAS,EAAE,EAAEiB,GAAG,EAAE;MACtC,IAAIC,KAAK,GAAGZ,QAAQ,CAACU,GAAG,EAAEC,GAAG,CAAC;IAClC;EACJ;AACJ,CAAC;AAAC,KArCIV,aAAa;AAuCnB,eAAeA,aAAa;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}