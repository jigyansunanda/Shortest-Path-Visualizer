{"ast":null,"code":"import Editor from\"@monaco-editor/react\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var options={readOnly:true,minimap:{enabled:false},automaticLayout:true,scrollBeyondLastLine:false,fontSize:\"13px\",lineNumbers:\"off\",glyphMargin:false,folding:false,lineDecorationsWidth:5,renderIndentGuides:false};var FloydWarshallcode=\"function FloydWarshall(Graph[V, E], source, destination) {\\n    1. intialize distance[V][V]\\n    2. for (i from 1 to V) {\\n            for (j from 1 to V) {\\n                if (Edge from i to j exists) distance[i][j] = weight(i, j)\\n                else if (i == j) distance[i][j] = 0\\n                else distance[i][j] = Infinity\\n            }\\n        }\\n    3. for (k from 1 to V) {\\n            for (i from 1 to V) {\\n                for (j from 1 to V) {\\n                    if (distance[i][k] === Infinity || distance[k][j] === Infinity) {\\n                        continue\\n                    }\\n                    if (distance[i][j] > distance[i][k] + distance[k][j]) {\\n                        distance[i][j] = distance[i][k] + distance[k][j]\\n                    }\\n                }\\n            }\\n        }\\n4. return distance[source][destination]\\n}\";var FloydWarshallInfo=function FloydWarshallInfo(){return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"p\",{children:[\"Floyd Warshall \",/*#__PURE__*/_jsx(\"strong\",{children:\"All Pair Shortest Path (APSP)\"}),\"\\xA0 algorithm is a\\xA0\",/*#__PURE__*/_jsx(\"a\",{className:\"links\",href:\"https://en.wikipedia.org/wiki/Dynamic_programming\",target:\"_blank\",rel:\"noopener noreferrer\",children:\"dynamic programming\"}),\"\\xA0based algorithm, that computes shortest distances between all possible pair(source, destination) of vertices. This algorithm is relatively slower than even Bellman Ford algorithm. For slightly higher number of vertices this algorithm takes quite some time to compute all pair shortest paths.\"]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"The crucial advantage of this algorithm is that, after computation, it gives shortest paths among\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"all possible pairs of source and destination\"}),\"\\xA0 vertex, \",/*#__PURE__*/_jsx(\"strong\",{children:\"iff\"}),\" path exists.\"]}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Idea behind the algorithm:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsx(\"li\",{children:\"For each vertex, we update all shortest path from any source to any destination vertex, that contains this vertex as an intermediate vertx.\"}),/*#__PURE__*/_jsx(\"li\",{children:\"For all pairs of source to destination, we check whether through this intermediate vertex, a shorter path is possible or not.\"})]})]})}),/*#__PURE__*/_jsx(Editor,{width:\"100%\",height:\"35vh\",theme:\"vs-dark\",defaultLanguage:\"javascript\",defaultValue:FloydWarshallcode,value:FloydWarshallcode,options:options}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsxs(\"strong\",{children:[\"Time Complexity:\\xA0\",/*#__PURE__*/_jsxs(\"code\",{children:[\"O(|V|\",/*#__PURE__*/_jsx(\"sup\",{children:\"3\"}),\")\"]})]}),/*#__PURE__*/_jsxs(\"p\",{children:[\"Where, \",/*#__PURE__*/_jsx(\"code\",{children:\"|V|\"}),\"\\xA0 = number of vertices\"]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Advantages:\"}),/*#__PURE__*/_jsxs(\"ul\",{children:[/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"weighted & unweighted\"}),\" graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both \",/*#__PURE__*/_jsx(\"strong\",{children:\"cyclic & acyclic\"}),\"\\xA0graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for both\\xA0\",/*#__PURE__*/_jsx(\"strong\",{children:\"directed & undirected\"}),\" graph\"]}),/*#__PURE__*/_jsxs(\"li\",{children:[\"Works for \",/*#__PURE__*/_jsx(\"strong\",{children:\"negative weight edges\"})]}),/*#__PURE__*/_jsx(\"li\",{children:\"Detects negative weight edge cycles, if any\"})]})]}),/*#__PURE__*/_jsxs(\"li\",{children:[/*#__PURE__*/_jsx(\"strong\",{children:\"Disadvantages:\"}),/*#__PURE__*/_jsx(\"ul\",{children:/*#__PURE__*/_jsx(\"li\",{children:\"Very high time complexity\"})})]})]})]});};export default FloydWarshallInfo;","map":{"version":3,"names":["Editor","options","readOnly","minimap","enabled","automaticLayout","scrollBeyondLastLine","fontSize","lineNumbers","glyphMargin","folding","lineDecorationsWidth","renderIndentGuides","FloydWarshallcode","FloydWarshallInfo"],"sources":["/Users/jigyansu_nanda/Desktop/shortest-path-visualizer/src/components/algorithms-info/info/FloydWarshallInfo.js"],"sourcesContent":["import Editor from \"@monaco-editor/react\";\n\nconst options = {\n    readOnly: true,\n    minimap: { enabled: false },\n    automaticLayout: true,\n    scrollBeyondLastLine: false,\n    fontSize: \"13px\",\n    lineNumbers: \"off\",\n    glyphMargin: false,\n    folding: false,\n    lineDecorationsWidth: 5,\n    renderIndentGuides: false,\n};\n\nconst FloydWarshallcode = `function FloydWarshall(Graph[V, E], source, destination) {\n    1. intialize distance[V][V]\n    2. for (i from 1 to V) {\n            for (j from 1 to V) {\n                if (Edge from i to j exists) distance[i][j] = weight(i, j)\n                else if (i == j) distance[i][j] = 0\n                else distance[i][j] = Infinity\n            }\n        }\n    3. for (k from 1 to V) {\n            for (i from 1 to V) {\n                for (j from 1 to V) {\n                    if (distance[i][k] === Infinity || distance[k][j] === Infinity) {\n                        continue\n                    }\n                    if (distance[i][j] > distance[i][k] + distance[k][j]) {\n                        distance[i][j] = distance[i][k] + distance[k][j]\n                    }\n                }\n            }\n        }\n4. return distance[source][destination]\n}`;\n\nconst FloydWarshallInfo = () => {\n    return (\n        <div>\n            <p>\n                Floyd Warshall <strong>All Pair Shortest Path (APSP)</strong>\n                &nbsp; algorithm is a&nbsp;\n                <a\n                    className=\"links\"\n                    href=\"https://en.wikipedia.org/wiki/Dynamic_programming\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    dynamic programming\n                </a>\n                &nbsp;based algorithm, that computes shortest distances between\n                all possible pair(source, destination) of vertices. This\n                algorithm is relatively slower than even Bellman Ford algorithm.\n                For slightly higher number of vertices this algorithm takes\n                quite some time to compute all pair shortest paths.\n            </p>\n            <p>\n                The crucial advantage of this algorithm is that, after\n                computation, it gives shortest paths among&nbsp;\n                <strong>all possible pairs of source and destination</strong>\n                &nbsp; vertex, <strong>iff</strong> path exists.\n            </p>\n            <ul>\n                <li>\n                    <strong>Idea behind the algorithm:</strong>\n                    <ul>\n                        <li>\n                            For each vertex, we update all shortest path from\n                            any source to any destination vertex, that contains\n                            this vertex as an intermediate vertx.\n                        </li>\n                        <li>\n                            For all pairs of source to destination, we check\n                            whether through this intermediate vertex, a shorter\n                            path is possible or not.\n                        </li>\n                    </ul>\n                </li>\n            </ul>\n            <Editor\n                width=\"100%\"\n                height=\"35vh\"\n                theme=\"vs-dark\"\n                defaultLanguage=\"javascript\"\n                defaultValue={FloydWarshallcode}\n                value={FloydWarshallcode}\n                options={options}\n            />\n            <ul>\n                <li>\n                    <strong>\n                        Time Complexity:&nbsp;\n                        <code>\n                            O(|V|<sup>3</sup>)\n                        </code>\n                    </strong>\n                    <p>\n                        Where, <code>|V|</code>&nbsp; = number of vertices\n                    </p>\n                </li>\n                <li>\n                    <strong>Advantages:</strong>\n                    <ul>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>weighted & unweighted</strong> graph\n                        </li>\n                        <li>\n                            Works for both <strong>cyclic & acyclic</strong>\n                            &nbsp;graph\n                        </li>\n                        <li>\n                            Works for both&nbsp;\n                            <strong>directed & undirected</strong> graph\n                        </li>\n                        <li>\n                            Works for <strong>negative weight edges</strong>\n                        </li>\n                        <li>Detects negative weight edge cycles, if any</li>\n                    </ul>\n                </li>\n                <li>\n                    <strong>Disadvantages:</strong>\n                    <ul>\n                        <li>Very high time complexity</li>\n                    </ul>\n                </li>\n            </ul>\n        </div>\n    );\n};\n\nexport default FloydWarshallInfo;\n"],"mappings":"AAAA,MAAOA,OAAM,KAAM,sBAAsB,CAAC,wFAE1C,GAAMC,QAAO,CAAG,CACZC,QAAQ,CAAE,IAAI,CACdC,OAAO,CAAE,CAAEC,OAAO,CAAE,KAAM,CAAC,CAC3BC,eAAe,CAAE,IAAI,CACrBC,oBAAoB,CAAE,KAAK,CAC3BC,QAAQ,CAAE,MAAM,CAChBC,WAAW,CAAE,KAAK,CAClBC,WAAW,CAAE,KAAK,CAClBC,OAAO,CAAE,KAAK,CACdC,oBAAoB,CAAE,CAAC,CACvBC,kBAAkB,CAAE,KACxB,CAAC,CAED,GAAMC,kBAAiB,y2BAsBrB,CAEF,GAAMC,kBAAiB,CAAG,QAApBA,kBAAiB,EAAS,CAC5B,mBACI,oCACI,oDACmB,yDAA8C,wCAE7D,UACI,SAAS,CAAC,OAAO,CACjB,IAAI,CAAC,mDAAmD,CACxD,MAAM,CAAC,QAAQ,CACf,GAAG,CAAC,qBAAqB,iCAGzB,6SAMJ,cACJ,0IAGI,wEAA6D,8BAC9C,+BAAoB,mBACnC,cACJ,iCACI,mCACI,sDAA2C,cAC3C,mCACI,mKAIK,cACL,qJAIK,GACJ,GACJ,EACJ,cACL,KAAC,MAAM,EACH,KAAK,CAAC,MAAM,CACZ,MAAM,CAAC,MAAM,CACb,KAAK,CAAC,SAAS,CACf,eAAe,CAAC,YAAY,CAC5B,YAAY,CAAED,iBAAkB,CAChC,KAAK,CAAEA,iBAAkB,CACzB,OAAO,CAAEZ,OAAQ,EACnB,cACF,mCACI,mCACI,8DAEI,6CACS,0BAAY,OACd,GACF,cACT,4CACW,6BAAgB,+BACvB,GACH,cACL,mCACI,uCAA4B,cAC5B,mCACI,wDAEI,iDAAsC,YACrC,cACL,qDACmB,4CAAiC,eAE/C,cACL,wDAEI,iDAAsC,YACrC,cACL,gDACc,iDAAsC,GAC/C,cACL,mEAAoD,GACnD,GACJ,cACL,mCACI,0CAA+B,cAC/B,iCACI,iDAAkC,EACjC,GACJ,GACJ,GACH,CAEd,CAAC,CAED,cAAea,kBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}